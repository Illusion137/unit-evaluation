#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_chemistry_acids_bases() {
    
    // ========================================================================
    // pH: pH = -log[H+]
    // ========================================================================
    
    formulas.push_back({
        "pH (solve for pH)",
        "\\text{pH} = -\\log[H^+]",
        {
            {"\\text{pH}", {0, 0, 0, 0, 0, 0, 0}, "pH", false},
            {"[H^+]", {-3, 0, 0, 0, 0, 1, 0}, "Hydrogen ion concentration", false}
        },
        "Chemistry - Acids & Bases",
        "pH",
        "\\text{pH}"
    });
    
    formulas.push_back({
        "pH (solve for H+)",
        "[H^+] = 10^{-\\text{pH}}",
        {
            {"[H^+]", {-3, 0, 0, 0, 0, 1, 0}, "Hydrogen ion concentration", false},
            {"\\text{pH}", {0, 0, 0, 0, 0, 0, 0}, "pH", false}
        },
        "Chemistry - Acids & Bases",
        "pH",
        "[H^+]"
    });
    
    // ========================================================================
    // pOH: pOH = -log[OH-]
    // ========================================================================
    
    formulas.push_back({
        "pOH (solve for pOH)",
        "\\text{pOH} = -\\log[OH^-]",
        {
            {"\\text{pOH}", {0, 0, 0, 0, 0, 0, 0}, "pOH", false},
            {"[OH^-]", {-3, 0, 0, 0, 0, 1, 0}, "Hydroxide ion concentration", false}
        },
        "Chemistry - Acids & Bases",
        "pOH",
        "\\text{pOH}"
    });
    
    formulas.push_back({
        "pOH (solve for OH-)",
        "[OH^-] = 10^{-\\text{pOH}}",
        {
            {"[OH^-]", {-3, 0, 0, 0, 0, 1, 0}, "Hydroxide ion concentration", false},
            {"\\text{pOH}", {0, 0, 0, 0, 0, 0, 0}, "pOH", false}
        },
        "Chemistry - Acids & Bases",
        "pOH",
        "[OH^-]"
    });
    
    // ========================================================================
    // pH + pOH = 14 (at 25°C)
    // ========================================================================
    
    formulas.push_back({
        "pH and pOH Relationship (solve for pH)",
        "\\text{pH} = 14 - \\text{pOH}",
        {
            {"\\text{pH}", {0, 0, 0, 0, 0, 0, 0}, "pH", false},
            {"\\text{pOH}", {0, 0, 0, 0, 0, 0, 0}, "pOH", false}
        },
        "Chemistry - Acids & Bases",
        "pH and pOH Relationship",
        "\\text{pH}"
    });
    
    formulas.push_back({
        "pH and pOH Relationship (solve for pOH)",
        "\\text{pOH} = 14 - \\text{pH}",
        {
            {"\\text{pOH}", {0, 0, 0, 0, 0, 0, 0}, "pOH", false},
            {"\\text{pH}", {0, 0, 0, 0, 0, 0, 0}, "pH", false}
        },
        "Chemistry - Acids & Bases",
        "pH and pOH Relationship",
        "\\text{pOH}"
    });
    
    // ========================================================================
    // pK_a: pK_a = -log(K_a)
    // ========================================================================
    
    formulas.push_back({
        "pKa (solve for pK_a)",
        "\\text{pK}_a = -\\log K_a",
        {
            {"\\text{pK}_a", {0, 0, 0, 0, 0, 0, 0}, "pKa", false},
            {"K_a", {0, 0, 0, 0, 0, 0, 0}, "Acid dissociation constant", false}
        },
        "Chemistry - Acids & Bases",
        "pKa",
        "\\text{pK}_a"
    });
    
    formulas.push_back({
        "pKa (solve for K_a)",
        "K_a = 10^{-\\text{pK}_a}",
        {
            {"K_a", {0, 0, 0, 0, 0, 0, 0}, "Acid dissociation constant", false},
            {"\\text{pK}_a", {0, 0, 0, 0, 0, 0, 0}, "pKa", false}
        },
        "Chemistry - Acids & Bases",
        "pKa",
        "K_a"
    });
    
    // ========================================================================
    // pK_b: pK_b = -log(K_b)
    // ========================================================================
    
    formulas.push_back({
        "pKb (solve for pK_b)",
        "\\text{pK}_b = -\\log K_b",
        {
            {"\\text{pK}_b", {0, 0, 0, 0, 0, 0, 0}, "pKb", false},
            {"K_b", {0, 0, 0, 0, 0, 0, 0}, "Base dissociation constant", false}
        },
        "Chemistry - Acids & Bases",
        "pKb",
        "\\text{pK}_b"
    });
    
    formulas.push_back({
        "pKb (solve for K_b)",
        "K_b = 10^{-\\text{pK}_b}",
        {
            {"K_b", {0, 0, 0, 0, 0, 0, 0}, "Base dissociation constant", false},
            {"\\text{pK}_b", {0, 0, 0, 0, 0, 0, 0}, "pKb", false}
        },
        "Chemistry - Acids & Bases",
        "pKb",
        "K_b"
    });
    
    // ========================================================================
    // pK_a + pK_b = 14 (at 25°C)
    // ========================================================================
    
    formulas.push_back({
        "pKa and pKb Relationship (solve for pK_a)",
        "\\text{pK}_a = 14 - \\text{pK}_b",
        {
            {"\\text{pK}_a", {0, 0, 0, 0, 0, 0, 0}, "pKa", false},
            {"\\text{pK}_b", {0, 0, 0, 0, 0, 0, 0}, "pKb", false}
        },
        "Chemistry - Acids & Bases",
        "pKa and pKb Relationship",
        "\\text{pK}_a"
    });
    
    formulas.push_back({
        "pKa and pKb Relationship (solve for pK_b)",
        "\\text{pK}_b = 14 - \\text{pK}_a",
        {
            {"\\text{pK}_b", {0, 0, 0, 0, 0, 0, 0}, "pKb", false},
            {"\\text{pK}_a", {0, 0, 0, 0, 0, 0, 0}, "pKa", false}
        },
        "Chemistry - Acids & Bases",
        "pKa and pKb Relationship",
        "\\text{pK}_b"
    });
    
    // ========================================================================
    // HENDERSON-HASSELBALCH EQUATION: pH = pK_a + log([A-]/[HA])
    // ========================================================================
    
    formulas.push_back({
        "Henderson-Hasselbalch (solve for pH)",
        "\\text{pH} = \\text{pK}_a + \\log\\frac{[A^-]}{[HA]}",
        {
            {"\\text{pH}", {0, 0, 0, 0, 0, 0, 0}, "pH", false},
            {"\\text{pK}_a", {0, 0, 0, 0, 0, 0, 0}, "pKa", false},
            {"[A^-]", {-3, 0, 0, 0, 0, 1, 0}, "Conjugate base concentration", false},
            {"[HA]", {-3, 0, 0, 0, 0, 1, 0}, "Weak acid concentration", false}
        },
        "Chemistry - Acids & Bases",
        "Henderson-Hasselbalch",
        "\\text{pH}"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_chemistry_basic() {
    
    // ========================================================================
    // IDEAL GAS LAW: PV = nRT
    // ========================================================================
    
    formulas.push_back({
        "Ideal Gas Law (solve for P)",
        "P = \\frac{nRT}{V}",
        {
            {"P", {-1, -2, 1, 0, 0, 0, 0}, "Pressure", false},
            {"n", {0, 0, 0, 0, 0, 1, 0}, "Moles", false},
            {"R", {2, -2, 1, 0, -1, -1, 0}, "Gas constant", true},
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false}
        },
        "Chemistry - Basic",
        "Ideal Gas Law",
        "P"
    });
    
    formulas.push_back({
        "Ideal Gas Law (solve for V)",
        "V = \\frac{nRT}{P}",
        {
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false},
            {"n", {0, 0, 0, 0, 0, 1, 0}, "Moles", false},
            {"R", {2, -2, 1, 0, -1, -1, 0}, "Gas constant", true},
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false},
            {"P", {-1, -2, 1, 0, 0, 0, 0}, "Pressure", false}
        },
        "Chemistry - Basic",
        "Ideal Gas Law",
        "V"
    });
    
    formulas.push_back({
        "Ideal Gas Law (solve for n)",
        "n = \\frac{PV}{RT}",
        {
            {"n", {0, 0, 0, 0, 0, 1, 0}, "Moles", false},
            {"P", {-1, -2, 1, 0, 0, 0, 0}, "Pressure", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false},
            {"R", {2, -2, 1, 0, -1, -1, 0}, "Gas constant", true},
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false}
        },
        "Chemistry - Basic",
        "Ideal Gas Law",
        "n"
    });
    
    formulas.push_back({
        "Ideal Gas Law (solve for T)",
        "T = \\frac{PV}{nR}",
        {
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false},
            {"P", {-1, -2, 1, 0, 0, 0, 0}, "Pressure", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false},
            {"n", {0, 0, 0, 0, 0, 1, 0}, "Moles", false},
            {"R", {2, -2, 1, 0, -1, -1, 0}, "Gas constant", true}
        },
        "Chemistry - Basic",
        "Ideal Gas Law",
        "T"
    });
    
    // ========================================================================
    // MOLAR MASS: M = m / n
    // ========================================================================
    
    formulas.push_back({
        "Molar Mass (solve for M)",
        "M = \\frac{m}{n}",
        {
            {"M", {0, 0, 1, 0, 0, -1, 0}, "Molar mass", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"n", {0, 0, 0, 0, 0, 1, 0}, "Moles", false}
        },
        "Chemistry - Basic",
        "Molar Mass",
        "M"
    });
    
    formulas.push_back({
        "Molar Mass (solve for m)",
        "m = Mn",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"M", {0, 0, 1, 0, 0, -1, 0}, "Molar mass", false},
            {"n", {0, 0, 0, 0, 0, 1, 0}, "Moles", false}
        },
        "Chemistry - Basic",
        "Molar Mass",
        "m"
    });
    
    formulas.push_back({
        "Molar Mass (solve for n)",
        "n = \\frac{m}{M}",
        {
            {"n", {0, 0, 0, 0, 0, 1, 0}, "Moles", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"M", {0, 0, 1, 0, 0, -1, 0}, "Molar mass", false}
        },
        "Chemistry - Basic",
        "Molar Mass",
        "n"
    });
    
    // ========================================================================
    // DENSITY: rho = m / V (already in fluids, but repeated for chemistry)
    // ========================================================================
    
    formulas.push_back({
        "Density (solve for rho)",
        "\\rho = \\frac{m}{V}",
        {
            {"\\rho", {-3, 0, 1, 0, 0, 0, 0}, "Density", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false}
        },
        "Chemistry - Basic",
        "Density",
        "\\rho"
    });
    
    formulas.push_back({
        "Density (solve for m)",
        "m = \\rho V",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"\\rho", {-3, 0, 1, 0, 0, 0, 0}, "Density", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false}
        },
        "Chemistry - Basic",
        "Density",
        "m"
    });
    
    formulas.push_back({
        "Density (solve for V)",
        "V = \\frac{m}{\\rho}",
        {
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"\\rho", {-3, 0, 1, 0, 0, 0, 0}, "Density", false}
        },
        "Chemistry - Basic",
        "Density",
        "V"
    });
    
    // ========================================================================
    // PERCENT COMPOSITION: percent = (mass_component / mass_total) * 100
    // ========================================================================
    
    formulas.push_back({
        "Percent Composition (solve for percent)",
        "\\% = \\frac{m_{component}}{m_{total}} \\times 100",
        {
            {"\\%", {0, 0, 0, 0, 0, 0, 0}, "Percent", false},
            {"m_{component}", {0, 0, 1, 0, 0, 0, 0}, "Component mass", false},
            {"m_{total}", {0, 0, 1, 0, 0, 0, 0}, "Total mass", false}
        },
        "Chemistry - Basic",
        "Percent Composition",
        "\\%"
    });
    
    formulas.push_back({
        "Percent Composition (solve for m_component)",
        "m_{component} = \\frac{\\% \\times m_{total}}{100}",
        {
            {"m_{component}", {0, 0, 1, 0, 0, 0, 0}, "Component mass", false},
            {"\\%", {0, 0, 0, 0, 0, 0, 0}, "Percent", false},
            {"m_{total}", {0, 0, 1, 0, 0, 0, 0}, "Total mass", false}
        },
        "Chemistry - Basic",
        "Percent Composition",
        "m_{component}"
    });
    
    formulas.push_back({
        "Percent Composition (solve for m_total)",
        "m_{total} = \\frac{100 \\times m_{component}}{\\%}",
        {
            {"m_{total}", {0, 0, 1, 0, 0, 0, 0}, "Total mass", false},
            {"m_{component}", {0, 0, 1, 0, 0, 0, 0}, "Component mass", false},
            {"\\%", {0, 0, 0, 0, 0, 0, 0}, "Percent", false}
        },
        "Chemistry - Basic",
        "Percent Composition",
        "m_{total}"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_chemistry_electrochemistry() {
    
    // ========================================================================
    // CELL POTENTIAL: E_cell = E_cathode - E_anode
    // ========================================================================
    
    formulas.push_back({
        "Cell Potential (solve for E_cell)",
        "E_{cell} = E_{cathode} - E_{anode}",
        {
            {"E_{cell}", {2, -3, 1, -1, 0, 0, 0}, "Cell potential", false},
            {"E_{cathode}", {2, -3, 1, -1, 0, 0, 0}, "Cathode potential", false},
            {"E_{anode}", {2, -3, 1, -1, 0, 0, 0}, "Anode potential", false}
        },
        "Chemistry - Electrochemistry",
        "Cell Potential",
        "E_{cell}"
    });
    
    formulas.push_back({
        "Cell Potential (solve for E_cathode)",
        "E_{cathode} = E_{cell} + E_{anode}",
        {
            {"E_{cathode}", {2, -3, 1, -1, 0, 0, 0}, "Cathode potential", false},
            {"E_{cell}", {2, -3, 1, -1, 0, 0, 0}, "Cell potential", false},
            {"E_{anode}", {2, -3, 1, -1, 0, 0, 0}, "Anode potential", false}
        },
        "Chemistry - Electrochemistry",
        "Cell Potential",
        "E_{cathode}"
    });
    
    formulas.push_back({
        "Cell Potential (solve for E_anode)",
        "E_{anode} = E_{cathode} - E_{cell}",
        {
            {"E_{anode}", {2, -3, 1, -1, 0, 0, 0}, "Anode potential", false},
            {"E_{cathode}", {2, -3, 1, -1, 0, 0, 0}, "Cathode potential", false},
            {"E_{cell}", {2, -3, 1, -1, 0, 0, 0}, "Cell potential", false}
        },
        "Chemistry - Electrochemistry",
        "Cell Potential",
        "E_{anode}"
    });
    
    // ========================================================================
    // NERNST EQUATION: E = E° - (RT/nF) * ln(Q)
    // Simplified at 25°C: E = E° - (0.0592/n) * log(Q)
    // ========================================================================
    
    formulas.push_back({
        "Nernst Equation (general form)",
        "E = E^\\circ - \\frac{RT}{nF}\\ln Q",
        {
            {"E", {2, -3, 1, -1, 0, 0, 0}, "Cell potential", false},
            {"E^\\circ", {2, -3, 1, -1, 0, 0, 0}, "Standard cell potential", false},
            {"R", {2, -2, 1, 0, -1, -1, 0}, "Gas constant", true},
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false},
            {"n", {0, 0, 0, 0, 0, 0, 0}, "Number of electrons transferred", false},
            {"F", {0, 1, 0, 1, 0, -1, 0}, "Faraday constant", true},
            {"Q", {0, 0, 0, 0, 0, 0, 0}, "Reaction quotient", false}
        },
        "Chemistry - Electrochemistry",
        "Nernst Equation",
        "E"
    });
    
    // ========================================================================
    // FARADAY'S LAW OF ELECTROLYSIS: m = (Q * M) / (n * F)
    // Where Q = charge, M = molar mass, n = electrons, F = Faraday constant
    // ========================================================================
    
    formulas.push_back({
        "Faraday's Law of Electrolysis (solve for m)",
        "m = \\frac{QM}{nF}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass deposited", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Total charge", false},
            {"M", {0, 0, 1, 0, 0, -1, 0}, "Molar mass", false},
            {"n", {0, 0, 0, 0, 0, 0, 0}, "Number of electrons", false},
            {"F", {0, 1, 0, 1, 0, -1, 0}, "Faraday constant", true}
        },
        "Chemistry - Electrochemistry",
        "Faraday's Law of Electrolysis",
        "m"
    });
    
    formulas.push_back({
        "Faraday's Law of Electrolysis (solve for Q)",
        "Q = \\frac{mnF}{M}",
        {
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Total charge", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass deposited", false},
            {"n", {0, 0, 0, 0, 0, 0, 0}, "Number of electrons", false},
            {"F", {0, 1, 0, 1, 0, -1, 0}, "Faraday constant", true},
            {"M", {0, 0, 1, 0, 0, -1, 0}, "Molar mass", false}
        },
        "Chemistry - Electrochemistry",
        "Faraday's Law of Electrolysis",
        "Q"
    });
    
    // ========================================================================
    // CHARGE: Q = I * t
    // ========================================================================
    
    formulas.push_back({
        "Charge (solve for Q)",
        "Q = It",
        {
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Chemistry - Electrochemistry",
        "Charge",
        "Q"
    });
    
    formulas.push_back({
        "Charge (solve for I)",
        "I = \\frac{Q}{t}",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Chemistry - Electrochemistry",
        "Charge",
        "I"
    });
    
    formulas.push_back({
        "Charge (solve for t)",
        "t = \\frac{Q}{I}",
        {
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Chemistry - Electrochemistry",
        "Charge",
        "t"
    });
    
    // ========================================================================
    // GIBBS FREE ENERGY AND CELL POTENTIAL: Delta_G = -n * F * E
    // ========================================================================
    
    formulas.push_back({
        "Gibbs Free Energy from Cell Potential (solve for Delta_G)",
        "\\Delta G = -nFE",
        {
            {"\\Delta G", {2, -2, 1, 0, 0, 0, 0}, "Gibbs free energy change", false},
            {"n", {0, 0, 0, 0, 0, 0, 0}, "Number of electrons", false},
            {"F", {0, 1, 0, 1, 0, -1, 0}, "Faraday constant", true},
            {"E", {2, -3, 1, -1, 0, 0, 0}, "Cell potential", false}
        },
        "Chemistry - Electrochemistry",
        "Gibbs Free Energy from Cell Potential",
        "\\Delta G"
    });
    
    formulas.push_back({
        "Gibbs Free Energy from Cell Potential (solve for E)",
        "E = -\\frac{\\Delta G}{nF}",
        {
            {"E", {2, -3, 1, -1, 0, 0, 0}, "Cell potential", false},
            {"\\Delta G", {2, -2, 1, 0, 0, 0, 0}, "Gibbs free energy change", false},
            {"n", {0, 0, 0, 0, 0, 0, 0}, "Number of electrons", false},
            {"F", {0, 1, 0, 1, 0, -1, 0}, "Faraday constant", true}
        },
        "Chemistry - Electrochemistry",
        "Gibbs Free Energy from Cell Potential",
        "E"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_chemistry_equilibrium() {
    
    // ========================================================================
    // EQUILIBRIUM CONSTANT (generic relationship)
    // K_c = [products] / [reactants]
    // ========================================================================
    
    formulas.push_back({
        "Equilibrium Constant (conceptual)",
        "K_c = \\frac{[C]^c[D]^d}{[A]^a[B]^b}",
        {
            {"K_c", {0, 0, 0, 0, 0, 0, 0}, "Equilibrium constant", false},
            {"[C]", {-3, 0, 0, 0, 0, 1, 0}, "Concentration of C", false},
            {"[D]", {-3, 0, 0, 0, 0, 1, 0}, "Concentration of D", false},
            {"[A]", {-3, 0, 0, 0, 0, 1, 0}, "Concentration of A", false},
            {"[B]", {-3, 0, 0, 0, 0, 1, 0}, "Concentration of B", false}
        },
        "Chemistry - Equilibrium",
        "Equilibrium Constant",
        "K_c"
    });
    
    // ========================================================================
    // RELATIONSHIP BETWEEN K_c AND K_p: K_p = K_c * (RT)^(Delta_n)
    // ========================================================================
    
    formulas.push_back({
        "Kp and Kc Relationship (conceptual)",
        "K_p = K_c(RT)^{\\Delta n}",
        {
            {"K_p", {0, 0, 0, 0, 0, 0, 0}, "Pressure equilibrium constant", false},
            {"K_c", {0, 0, 0, 0, 0, 0, 0}, "Concentration equilibrium constant", false},
            {"R", {2, -2, 1, 0, -1, -1, 0}, "Gas constant", true},
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false},
            {"\\Delta n", {0, 0, 0, 0, 0, 0, 0}, "Change in moles of gas", false}
        },
        "Chemistry - Equilibrium",
        "Kp and Kc Relationship",
        "K_p"
    });
    
    // ========================================================================
    // REACTION QUOTIENT: Q has same form as K
    // ========================================================================
    
    formulas.push_back({
        "Reaction Quotient (conceptual)",
        "Q = \\frac{[C]^c[D]^d}{[A]^a[B]^b}",
        {
            {"Q", {0, 0, 0, 0, 0, 0, 0}, "Reaction quotient", false},
            {"[C]", {-3, 0, 0, 0, 0, 1, 0}, "Concentration of C", false},
            {"[D]", {-3, 0, 0, 0, 0, 1, 0}, "Concentration of D", false},
            {"[A]", {-3, 0, 0, 0, 0, 1, 0}, "Concentration of A", false},
            {"[B]", {-3, 0, 0, 0, 0, 1, 0}, "Concentration of B", false}
        },
        "Chemistry - Equilibrium",
        "Reaction Quotient",
        "Q"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_chemistry_kinetics() {
    
    // ========================================================================
    // ARRHENIUS EQUATION: k = A * exp(-E_a / RT)
    // Logarithmic form: ln(k) = ln(A) - E_a/RT
    // ========================================================================
    
    formulas.push_back({
        "Arrhenius Equation Logarithmic (solve for ln_k)",
        "\\ln k = \\ln A - \\frac{E_a}{RT}",
        {
            {"\\ln k", {0, 0, 0, 0, 0, 0, 0}, "Natural log of rate constant", false},
            {"\\ln A", {0, 0, 0, 0, 0, 0, 0}, "Natural log of frequency factor", false},
            {"E_a", {2, -2, 1, 0, 0, 0, 0}, "Activation energy", false},
            {"R", {2, -2, 1, 0, -1, -1, 0}, "Gas constant", true},
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false}
        },
        "Chemistry - Kinetics",
        "Arrhenius Equation Logarithmic",
        "\\ln k"
    });
    
    // ========================================================================
    // FIRST ORDER HALF-LIFE: t_1/2 = 0.693 / k
    // ========================================================================
    
    formulas.push_back({
        "First Order Half-Life (solve for t_half)",
        "t_{1/2} = \\frac{0.693}{k}",
        {
            {"t_{1/2}", {0, 1, 0, 0, 0, 0, 0}, "Half-life", false},
            {"k", {0, -1, 0, 0, 0, 0, 0}, "Rate constant", false}
        },
        "Chemistry - Kinetics",
        "First Order Half-Life",
        "t_{1/2}"
    });
    
    formulas.push_back({
        "First Order Half-Life (solve for k)",
        "k = \\frac{0.693}{t_{1/2}}",
        {
            {"k", {0, -1, 0, 0, 0, 0, 0}, "Rate constant", false},
            {"t_{1/2}", {0, 1, 0, 0, 0, 0, 0}, "Half-life", false}
        },
        "Chemistry - Kinetics",
        "First Order Half-Life",
        "k"
    });
    
    // ========================================================================
    // FIRST ORDER INTEGRATED RATE LAW: ln[A] = ln[A]_0 - kt
    // ========================================================================
    
    formulas.push_back({
        "First Order Rate Law (relationship)",
        "\\ln[A] = \\ln[A]_0 - kt",
        {
            {"\\ln[A]", {0, 0, 0, 0, 0, 0, 0}, "Natural log of concentration", false},
            {"\\ln[A]_0", {0, 0, 0, 0, 0, 0, 0}, "Natural log of initial concentration", false},
            {"k", {0, -1, 0, 0, 0, 0, 0}, "Rate constant", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Chemistry - Kinetics",
        "First Order Rate Law",
        "relationship"
    });
    
    // ========================================================================
    // SECOND ORDER HALF-LIFE: t_1/2 = 1 / (k * [A]_0)
    // ========================================================================
    
    formulas.push_back({
        "Second Order Half-Life (solve for t_half)",
        "t_{1/2} = \\frac{1}{k[A]_0}",
        {
            {"t_{1/2}", {0, 1, 0, 0, 0, 0, 0}, "Half-life", false},
            {"k", {3, -1, 0, 0, 0, -1, 0}, "Rate constant", false},
            {"[A]_0", {-3, 0, 0, 0, 0, 1, 0}, "Initial concentration", false}
        },
        "Chemistry - Kinetics",
        "Second Order Half-Life",
        "t_{1/2}"
    });
    
    formulas.push_back({
        "Second Order Half-Life (solve for k)",
        "k = \\frac{1}{t_{1/2}[A]_0}",
        {
            {"k", {3, -1, 0, 0, 0, -1, 0}, "Rate constant", false},
            {"t_{1/2}", {0, 1, 0, 0, 0, 0, 0}, "Half-life", false},
            {"[A]_0", {-3, 0, 0, 0, 0, 1, 0}, "Initial concentration", false}
        },
        "Chemistry - Kinetics",
        "Second Order Half-Life",
        "k"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_chemistry_solutions() {
    
    // ========================================================================
    // MOLARITY: M = n / V
    // ========================================================================
    
    formulas.push_back({
        "Molarity (solve for M)",
        "M = \\frac{n}{V}",
        {
            {"M", {-3, 0, 0, 0, 0, 1, 0}, "Molarity", false},
            {"n", {0, 0, 0, 0, 0, 1, 0}, "Moles of solute", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume of solution", false}
        },
        "Chemistry - Solutions",
        "Molarity",
        "M"
    });
    
    formulas.push_back({
        "Molarity (solve for n)",
        "n = MV",
        {
            {"n", {0, 0, 0, 0, 0, 1, 0}, "Moles of solute", false},
            {"M", {-3, 0, 0, 0, 0, 1, 0}, "Molarity", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume of solution", false}
        },
        "Chemistry - Solutions",
        "Molarity",
        "n"
    });
    
    formulas.push_back({
        "Molarity (solve for V)",
        "V = \\frac{n}{M}",
        {
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume of solution", false},
            {"n", {0, 0, 0, 0, 0, 1, 0}, "Moles of solute", false},
            {"M", {-3, 0, 0, 0, 0, 1, 0}, "Molarity", false}
        },
        "Chemistry - Solutions",
        "Molarity",
        "V"
    });
    
    // ========================================================================
    // DILUTION: M_1 * V_1 = M_2 * V_2
    // ========================================================================
    
    formulas.push_back({
        "Dilution (solve for M_2)",
        "M_2 = \\frac{M_1 V_1}{V_2}",
        {
            {"M_2", {-3, 0, 0, 0, 0, 1, 0}, "Final molarity", false},
            {"M_1", {-3, 0, 0, 0, 0, 1, 0}, "Initial molarity", false},
            {"V_1", {3, 0, 0, 0, 0, 0, 0}, "Initial volume", false},
            {"V_2", {3, 0, 0, 0, 0, 0, 0}, "Final volume", false}
        },
        "Chemistry - Solutions",
        "Dilution",
        "M_2"
    });
    
    formulas.push_back({
        "Dilution (solve for V_2)",
        "V_2 = \\frac{M_1 V_1}{M_2}",
        {
            {"V_2", {3, 0, 0, 0, 0, 0, 0}, "Final volume", false},
            {"M_1", {-3, 0, 0, 0, 0, 1, 0}, "Initial molarity", false},
            {"V_1", {3, 0, 0, 0, 0, 0, 0}, "Initial volume", false},
            {"M_2", {-3, 0, 0, 0, 0, 1, 0}, "Final molarity", false}
        },
        "Chemistry - Solutions",
        "Dilution",
        "V_2"
    });
    
    formulas.push_back({
        "Dilution (solve for M_1)",
        "M_1 = \\frac{M_2 V_2}{V_1}",
        {
            {"M_1", {-3, 0, 0, 0, 0, 1, 0}, "Initial molarity", false},
            {"M_2", {-3, 0, 0, 0, 0, 1, 0}, "Final molarity", false},
            {"V_2", {3, 0, 0, 0, 0, 0, 0}, "Final volume", false},
            {"V_1", {3, 0, 0, 0, 0, 0, 0}, "Initial volume", false}
        },
        "Chemistry - Solutions",
        "Dilution",
        "M_1"
    });
    
    formulas.push_back({
        "Dilution (solve for V_1)",
        "V_1 = \\frac{M_2 V_2}{M_1}",
        {
            {"V_1", {3, 0, 0, 0, 0, 0, 0}, "Initial volume", false},
            {"M_2", {-3, 0, 0, 0, 0, 1, 0}, "Final molarity", false},
            {"V_2", {3, 0, 0, 0, 0, 0, 0}, "Final volume", false},
            {"M_1", {-3, 0, 0, 0, 0, 1, 0}, "Initial molarity", false}
        },
        "Chemistry - Solutions",
        "Dilution",
        "V_1"
    });
    
    // ========================================================================
    // MASS PERCENT: mass_percent = (mass_solute / mass_solution) * 100
    // ========================================================================
    
    formulas.push_back({
        "Mass Percent (solve for mass_percent)",
        "\\text{mass\\%} = \\frac{m_{solute}}{m_{solution}} \\times 100",
        {
            {"\\text{mass\\%}", {0, 0, 0, 0, 0, 0, 0}, "Mass percent", false},
            {"m_{solute}", {0, 0, 1, 0, 0, 0, 0}, "Mass of solute", false},
            {"m_{solution}", {0, 0, 1, 0, 0, 0, 0}, "Mass of solution", false}
        },
        "Chemistry - Solutions",
        "Mass Percent",
        "\\text{mass\\%}"
    });
    
    formulas.push_back({
        "Mass Percent (solve for m_solute)",
        "m_{solute} = \\frac{\\text{mass\\%} \\times m_{solution}}{100}",
        {
            {"m_{solute}", {0, 0, 1, 0, 0, 0, 0}, "Mass of solute", false},
            {"\\text{mass\\%}", {0, 0, 0, 0, 0, 0, 0}, "Mass percent", false},
            {"m_{solution}", {0, 0, 1, 0, 0, 0, 0}, "Mass of solution", false}
        },
        "Chemistry - Solutions",
        "Mass Percent",
        "m_{solute}"
    });
    
    formulas.push_back({
        "Mass Percent (solve for m_solution)",
        "m_{solution} = \\frac{100 \\times m_{solute}}{\\text{mass\\%}}",
        {
            {"m_{solution}", {0, 0, 1, 0, 0, 0, 0}, "Mass of solution", false},
            {"m_{solute}", {0, 0, 1, 0, 0, 0, 0}, "Mass of solute", false},
            {"\\text{mass\\%}", {0, 0, 0, 0, 0, 0, 0}, "Mass percent", false}
        },
        "Chemistry - Solutions",
        "Mass Percent",
        "m_{solution}"
    });
    
    // ========================================================================
    // MOLE FRACTION: X_A = n_A / n_total
    // ========================================================================
    
    formulas.push_back({
        "Mole Fraction (solve for X_A)",
        "X_A = \\frac{n_A}{n_{total}}",
        {
            {"X_A", {0, 0, 0, 0, 0, 0, 0}, "Mole fraction of A", false},
            {"n_A", {0, 0, 0, 0, 0, 1, 0}, "Moles of A", false},
            {"n_{total}", {0, 0, 0, 0, 0, 1, 0}, "Total moles", false}
        },
        "Chemistry - Solutions",
        "Mole Fraction",
        "X_A"
    });
    
    formulas.push_back({
        "Mole Fraction (solve for n_A)",
        "n_A = X_A n_{total}",
        {
            {"n_A", {0, 0, 0, 0, 0, 1, 0}, "Moles of A", false},
            {"X_A", {0, 0, 0, 0, 0, 0, 0}, "Mole fraction of A", false},
            {"n_{total}", {0, 0, 0, 0, 0, 1, 0}, "Total moles", false}
        },
        "Chemistry - Solutions",
        "Mole Fraction",
        "n_A"
    });
    
    formulas.push_back({
        "Mole Fraction (solve for n_total)",
        "n_{total} = \\frac{n_A}{X_A}",
        {
            {"n_{total}", {0, 0, 0, 0, 0, 1, 0}, "Total moles", false},
            {"n_A", {0, 0, 0, 0, 0, 1, 0}, "Moles of A", false},
            {"X_A", {0, 0, 0, 0, 0, 0, 0}, "Mole fraction of A", false}
        },
        "Chemistry - Solutions",
        "Mole Fraction",
        "n_{total}"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_chemistry_thermochemistry() {
    
    // ========================================================================
    // ENTHALPY CHANGE: Delta_H = H_products - H_reactants
    // ========================================================================
    
    formulas.push_back({
        "Enthalpy Change (solve for Delta_H)",
        "\\Delta H = H_{products} - H_{reactants}",
        {
            {"\\Delta H", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy change", false},
            {"H_{products}", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy of products", false},
            {"H_{reactants}", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy of reactants", false}
        },
        "Chemistry - Thermochemistry",
        "Enthalpy Change",
        "\\Delta H"
    });
    
    formulas.push_back({
        "Enthalpy Change (solve for H_products)",
        "H_{products} = \\Delta H + H_{reactants}",
        {
            {"H_{products}", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy of products", false},
            {"\\Delta H", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy change", false},
            {"H_{reactants}", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy of reactants", false}
        },
        "Chemistry - Thermochemistry",
        "Enthalpy Change",
        "H_{products}"
    });
    
    formulas.push_back({
        "Enthalpy Change (solve for H_reactants)",
        "H_{reactants} = H_{products} - \\Delta H",
        {
            {"H_{reactants}", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy of reactants", false},
            {"H_{products}", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy of products", false},
            {"\\Delta H", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy change", false}
        },
        "Chemistry - Thermochemistry",
        "Enthalpy Change",
        "H_{reactants}"
    });
    
    // ========================================================================
    // GIBBS FREE ENERGY: Delta_G = Delta_H - T * Delta_S
    // ========================================================================
    
    formulas.push_back({
        "Gibbs Free Energy (solve for Delta_G)",
        "\\Delta G = \\Delta H - T\\Delta S",
        {
            {"\\Delta G", {2, -2, 1, 0, 0, 0, 0}, "Gibbs free energy change", false},
            {"\\Delta H", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy change", false},
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false},
            {"\\Delta S", {2, -2, 1, 0, -1, 0, 0}, "Entropy change", false}
        },
        "Chemistry - Thermochemistry",
        "Gibbs Free Energy",
        "\\Delta G"
    });
    
    formulas.push_back({
        "Gibbs Free Energy (solve for Delta_H)",
        "\\Delta H = \\Delta G + T\\Delta S",
        {
            {"\\Delta H", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy change", false},
            {"\\Delta G", {2, -2, 1, 0, 0, 0, 0}, "Gibbs free energy change", false},
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false},
            {"\\Delta S", {2, -2, 1, 0, -1, 0, 0}, "Entropy change", false}
        },
        "Chemistry - Thermochemistry",
        "Gibbs Free Energy",
        "\\Delta H"
    });
    
    formulas.push_back({
        "Gibbs Free Energy (solve for T)",
        "T = \\frac{\\Delta H - \\Delta G}{\\Delta S}",
        {
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false},
            {"\\Delta H", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy change", false},
            {"\\Delta G", {2, -2, 1, 0, 0, 0, 0}, "Gibbs free energy change", false},
            {"\\Delta S", {2, -2, 1, 0, -1, 0, 0}, "Entropy change", false}
        },
        "Chemistry - Thermochemistry",
        "Gibbs Free Energy",
        "T"
    });
    
    formulas.push_back({
        "Gibbs Free Energy (solve for Delta_S)",
        "\\Delta S = \\frac{\\Delta H - \\Delta G}{T}",
        {
            {"\\Delta S", {2, -2, 1, 0, -1, 0, 0}, "Entropy change", false},
            {"\\Delta H", {2, -2, 1, 0, 0, 0, 0}, "Enthalpy change", false},
            {"\\Delta G", {2, -2, 1, 0, 0, 0, 0}, "Gibbs free energy change", false},
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false}
        },
        "Chemistry - Thermochemistry",
        "Gibbs Free Energy",
        "\\Delta S"
    });
    
    // ========================================================================
    // GIBBS FREE ENERGY AND EQUILIBRIUM: Delta_G = -RT * ln(K)
    // ========================================================================
    
    formulas.push_back({
        "Gibbs Free Energy and Equilibrium (solve for Delta_G)",
        "\\Delta G = -RT\\ln K",
        {
            {"\\Delta G", {2, -2, 1, 0, 0, 0, 0}, "Gibbs free energy change", false},
            {"R", {2, -2, 1, 0, -1, -1, 0}, "Gas constant", true},
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false},
            {"K", {0, 0, 0, 0, 0, 0, 0}, "Equilibrium constant", false}
        },
        "Chemistry - Thermochemistry",
        "Gibbs Free Energy and Equilibrium",
        "\\Delta G"
    });
    
    formulas.push_back({
        "Gibbs Free Energy and Equilibrium (solve for K)",
        "K = e^{-\\Delta G / RT}",
        {
            {"K", {0, 0, 0, 0, 0, 0, 0}, "Equilibrium constant", false},
            {"\\Delta G", {2, -2, 1, 0, 0, 0, 0}, "Gibbs free energy change", false},
            {"R", {2, -2, 1, 0, -1, -1, 0}, "Gas constant", true},
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false}
        },
        "Chemistry - Thermochemistry",
        "Gibbs Free Energy and Equilibrium",
        "K"
    });
    
    formulas.push_back({
        "Gibbs Free Energy and Equilibrium (solve for T)",
        "T = -\\frac{\\Delta G}{R\\ln K}",
        {
            {"T", {0, 0, 0, 0, 1, 0, 0}, "Temperature", false},
            {"\\Delta G", {2, -2, 1, 0, 0, 0, 0}, "Gibbs free energy change", false},
            {"R", {2, -2, 1, 0, -1, -1, 0}, "Gas constant", true},
            {"K", {0, 0, 0, 0, 0, 0, 0}, "Equilibrium constant", false}
        },
        "Chemistry - Thermochemistry",
        "Gibbs Free Energy and Equilibrium",
        "T"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_circuits() {
    
    // ========================================================================
    // OHM'S LAW: V = I * R
    // ========================================================================
    
    formulas.push_back({
        "Ohm's Law (solve for V)",
        "V = IR",
        {
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false}
        },
        "Circuits",
        "Ohm's Law",
        "V"
    });
    
    formulas.push_back({
        "Ohm's Law (solve for I)",
        "I = \\frac{V}{R}",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false}
        },
        "Circuits",
        "Ohm's Law",
        "I"
    });
    
    formulas.push_back({
        "Ohm's Law (solve for R)",
        "R = \\frac{V}{I}",
        {
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Circuits",
        "Ohm's Law",
        "R"
    });
    
    // ========================================================================
    // ELECTRIC POWER: P = I * V
    // ========================================================================
    
    formulas.push_back({
        "Electric Power (solve for P)",
        "P = IV",
        {
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false}
        },
        "Circuits",
        "Electric Power",
        "P"
    });
    
    formulas.push_back({
        "Electric Power (solve for I)",
        "I = \\frac{P}{V}",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false}
        },
        "Circuits",
        "Electric Power",
        "I"
    });
    
    formulas.push_back({
        "Electric Power (solve for V)",
        "V = \\frac{P}{I}",
        {
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false},
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Circuits",
        "Electric Power",
        "V"
    });
    
    // ========================================================================
    // POWER FROM CURRENT: P = I^2 * R
    // ========================================================================
    
    formulas.push_back({
        "Power from Current (solve for P)",
        "P = I^2 R",
        {
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false}
        },
        "Circuits",
        "Power from Current",
        "P"
    });
    
    formulas.push_back({
        "Power from Current (solve for I)",
        "I = \\sqrt{\\frac{P}{R}}",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false}
        },
        "Circuits",
        "Power from Current",
        "I"
    });
    
    formulas.push_back({
        "Power from Current (solve for R)",
        "R = \\frac{P}{I^2}",
        {
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false},
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Circuits",
        "Power from Current",
        "R"
    });
    
    // ========================================================================
    // POWER FROM VOLTAGE: P = V^2 / R
    // ========================================================================
    
    formulas.push_back({
        "Power from Voltage (solve for P)",
        "P = \\frac{V^2}{R}",
        {
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false}
        },
        "Circuits",
        "Power from Voltage",
        "P"
    });
    
    formulas.push_back({
        "Power from Voltage (solve for V)",
        "V = \\sqrt{PR}",
        {
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false},
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false}
        },
        "Circuits",
        "Power from Voltage",
        "V"
    });
    
    formulas.push_back({
        "Power from Voltage (solve for R)",
        "R = \\frac{V^2}{P}",
        {
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false},
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false}
        },
        "Circuits",
        "Power from Voltage",
        "R"
    });
    
    // ========================================================================
    // RESISTORS IN SERIES: R_total = R_1 + R_2
    // ========================================================================
    
    formulas.push_back({
        "Resistors in Series (solve for R_total)",
        "R_{total} = R_1 + R_2",
        {
            {"R_{total}", {2, -3, 1, -2, 0, 0, 0}, "Total resistance", false},
            {"R_1", {2, -3, 1, -2, 0, 0, 0}, "Resistance 1", false},
            {"R_2", {2, -3, 1, -2, 0, 0, 0}, "Resistance 2", false}
        },
        "Circuits",
        "Resistors in Series",
        "R_{total}"
    });
    
    formulas.push_back({
        "Resistors in Series (solve for R_1)",
        "R_1 = R_{total} - R_2",
        {
            {"R_1", {2, -3, 1, -2, 0, 0, 0}, "Resistance 1", false},
            {"R_{total}", {2, -3, 1, -2, 0, 0, 0}, "Total resistance", false},
            {"R_2", {2, -3, 1, -2, 0, 0, 0}, "Resistance 2", false}
        },
        "Circuits",
        "Resistors in Series",
        "R_1"
    });
    
    formulas.push_back({
        "Resistors in Series (solve for R_2)",
        "R_2 = R_{total} - R_1",
        {
            {"R_2", {2, -3, 1, -2, 0, 0, 0}, "Resistance 2", false},
            {"R_{total}", {2, -3, 1, -2, 0, 0, 0}, "Total resistance", false},
            {"R_1", {2, -3, 1, -2, 0, 0, 0}, "Resistance 1", false}
        },
        "Circuits",
        "Resistors in Series",
        "R_2"
    });
    
    // ========================================================================
    // RESISTORS IN PARALLEL (TWO): 1/R_total = 1/R_1 + 1/R_2
    // ========================================================================
    
    formulas.push_back({
        "Resistors in Parallel (solve for R_total)",
        "\\frac{1}{R_{total}} = \\frac{1}{R_1} + \\frac{1}{R_2}",
        {
            {"R_{total}", {2, -3, 1, -2, 0, 0, 0}, "Total resistance", false},
            {"R_1", {2, -3, 1, -2, 0, 0, 0}, "Resistance 1", false},
            {"R_2", {2, -3, 1, -2, 0, 0, 0}, "Resistance 2", false}
        },
        "Circuits",
        "Resistors in Parallel",
        "R_{total}"
    });
    
    formulas.push_back({
        "Resistors in Parallel Simplified (solve for R_total)",
        "R_{total} = \\frac{R_1 R_2}{R_1 + R_2}",
        {
            {"R_{total}", {2, -3, 1, -2, 0, 0, 0}, "Total resistance", false},
            {"R_1", {2, -3, 1, -2, 0, 0, 0}, "Resistance 1", false},
            {"R_2", {2, -3, 1, -2, 0, 0, 0}, "Resistance 2", false}
        },
        "Circuits",
        "Resistors in Parallel Simplified",
        "R_{total}"
    });
    
    // ========================================================================
    // RESISTANCE FROM RESISTIVITY: R = rho * L / A
    // ========================================================================
    
    formulas.push_back({
        "Resistance from Resistivity (solve for R)",
        "R = \\rho \\frac{L}{A}",
        {
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false},
            {"\\rho", {3, -3, 1, -2, 0, 0, 0}, "Resistivity", false},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false}
        },
        "Circuits",
        "Resistance from Resistivity",
        "R"
    });
    
    formulas.push_back({
        "Resistance from Resistivity (solve for rho)",
        "\\rho = R \\frac{A}{L}",
        {
            {"\\rho", {3, -3, 1, -2, 0, 0, 0}, "Resistivity", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false}
        },
        "Circuits",
        "Resistance from Resistivity",
        "\\rho"
    });
    
    formulas.push_back({
        "Resistance from Resistivity (solve for L)",
        "L = R \\frac{A}{\\rho}",
        {
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false},
            {"\\rho", {3, -3, 1, -2, 0, 0, 0}, "Resistivity", false}
        },
        "Circuits",
        "Resistance from Resistivity",
        "L"
    });
    
    formulas.push_back({
        "Resistance from Resistivity (solve for A)",
        "A = \\rho \\frac{L}{R}",
        {
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false},
            {"\\rho", {3, -3, 1, -2, 0, 0, 0}, "Resistivity", false},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false}
        },
        "Circuits",
        "Resistance from Resistivity",
        "A"
    });
    
    // ========================================================================
    // CURRENT DENSITY: J = I / A
    // ========================================================================
    
    formulas.push_back({
        "Current Density (solve for J)",
        "J = \\frac{I}{A}",
        {
            {"J", {-2, 0, 0, 1, 0, 0, 0}, "Current density", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false}
        },
        "Circuits",
        "Current Density",
        "J"
    });
    
    formulas.push_back({
        "Current Density (solve for I)",
        "I = JA",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"J", {-2, 0, 0, 1, 0, 0, 0}, "Current density", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false}
        },
        "Circuits",
        "Current Density",
        "I"
    });
    
    formulas.push_back({
        "Current Density (solve for A)",
        "A = \\frac{I}{J}",
        {
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"J", {-2, 0, 0, 1, 0, 0, 0}, "Current density", false}
        },
        "Circuits",
        "Current Density",
        "A"
    });
    
    // ========================================================================
    // RC TIME CONSTANT: tau = R * C
    // ========================================================================
    
    formulas.push_back({
        "RC Time Constant (solve for tau)",
        "\\tau = RC",
        {
            {"\\tau", {0, 1, 0, 0, 0, 0, 0}, "Time constant", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false}
        },
        "Circuits",
        "RC Time Constant",
        "\\tau"
    });
    
    formulas.push_back({
        "RC Time Constant (solve for R)",
        "R = \\frac{\\tau}{C}",
        {
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false},
            {"\\tau", {0, 1, 0, 0, 0, 0, 0}, "Time constant", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false}
        },
        "Circuits",
        "RC Time Constant",
        "R"
    });
    
    formulas.push_back({
        "RC Time Constant (solve for C)",
        "C = \\frac{\\tau}{R}",
        {
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false},
            {"\\tau", {0, 1, 0, 0, 0, 0, 0}, "Time constant", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false}
        },
        "Circuits",
        "RC Time Constant",
        "C"
    });
    
    // ========================================================================
    // ENERGY DISSIPATED: E = P * t
    // ========================================================================
    
    formulas.push_back({
        "Energy Dissipated (solve for E)",
        "E = Pt",
        {
            {"E", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Circuits",
        "Energy Dissipated",
        "E"
    });
    
    formulas.push_back({
        "Energy Dissipated (solve for P)",
        "P = \\frac{E}{t}",
        {
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"E", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Circuits",
        "Energy Dissipated",
        "P"
    });
    
    formulas.push_back({
        "Energy Dissipated (solve for t)",
        "t = \\frac{E}{P}",
        {
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false},
            {"E", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false}
        },
        "Circuits",
        "Energy Dissipated",
        "t"
    });
    // ========================================================================
    // DRIFT VELOCITY: I = n * q * v_d * A
    // ========================================================================
    
    formulas.push_back({
        "Drift Velocity (solve for I)",
        "I = nqv_d A",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"n", {-3, 0, 0, 0, 0, 0, 0}, "Charge carrier density", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge per carrier", false},
            {"v_d", {1, -1, 0, 0, 0, 0, 0}, "Drift velocity", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false}
        },
        "Circuits",
        "Drift Velocity",
        "I"
    });
    
    formulas.push_back({
        "Drift Velocity (solve for v_d)",
        "v_d = \\frac{I}{nqA}",
        {
            {"v_d", {1, -1, 0, 0, 0, 0, 0}, "Drift velocity", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"n", {-3, 0, 0, 0, 0, 0, 0}, "Charge carrier density", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge per carrier", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false}
        },
        "Circuits",
        "Drift Velocity",
        "v_d"
    });
    
    formulas.push_back({
        "Drift Velocity (solve for n)",
        "n = \\frac{I}{qv_d A}",
        {
            {"n", {-3, 0, 0, 0, 0, 0, 0}, "Charge carrier density", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge per carrier", false},
            {"v_d", {1, -1, 0, 0, 0, 0, 0}, "Drift velocity", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false}
        },
        "Circuits",
        "Drift Velocity",
        "n"
    });
    
    formulas.push_back({
        "Drift Velocity (solve for A)",
        "A = \\frac{I}{nqv_d}",
        {
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"n", {-3, 0, 0, 0, 0, 0, 0}, "Charge carrier density", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge per carrier", false},
            {"v_d", {1, -1, 0, 0, 0, 0, 0}, "Drift velocity", false}
        },
        "Circuits",
        "Drift Velocity",
        "A"
    });
    
    // ========================================================================
    // RESISTIVITY AND CONDUCTIVITY: sigma = 1 / rho
    // ========================================================================
    
    formulas.push_back({
        "Conductivity (solve for sigma)",
        "\\sigma = \\frac{1}{\\rho}",
        {
            {"\\sigma", {-3, 3, -1, 2, 0, 0, 0}, "Conductivity", false},
            {"\\rho", {3, -3, 1, -2, 0, 0, 0}, "Resistivity", false}
        },
        "Circuits",
        "Conductivity",
        "\\sigma"
    });
    
    formulas.push_back({
        "Conductivity (solve for rho)",
        "\\rho = \\frac{1}{\\sigma}",
        {
            {"\\rho", {3, -3, 1, -2, 0, 0, 0}, "Resistivity", false},
            {"\\sigma", {-3, 3, -1, 2, 0, 0, 0}, "Conductivity", false}
        },
        "Circuits",
        "Conductivity",
        "\\rho"
    });
    
    // ========================================================================
    // CONDUCTANCE: G = 1 / R
    // ========================================================================
    
    formulas.push_back({
        "Conductance (solve for G)",
        "G = \\frac{1}{R}",
        {
            {"G", {-2, 3, -1, 2, 0, 0, 0}, "Conductance", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false}
        },
        "Circuits",
        "Conductance",
        "G"
    });
    
    formulas.push_back({
        "Conductance (solve for R)",
        "R = \\frac{1}{G}",
        {
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false},
            {"G", {-2, 3, -1, 2, 0, 0, 0}, "Conductance", false}
        },
        "Circuits",
        "Conductance",
        "R"
    });
    
    // ========================================================================
    // TEMPERATURE DEPENDENCE OF RESISTANCE: R = R_0 * (1 + alpha * Delta_T)
    // ========================================================================
    
    formulas.push_back({
        "Temperature Dependence of Resistance (solve for R)",
        "R = R_0(1 + \\alpha\\Delta T)",
        {
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance at temperature T", false},
            {"R_0", {2, -3, 1, -2, 0, 0, 0}, "Resistance at reference temperature", false},
            {"\\alpha", {0, 0, 0, 0, -1, 0, 0}, "Temperature coefficient", false},
            {"\\Delta T", {0, 0, 0, 0, 1, 0, 0}, "Temperature change", false}
        },
        "Circuits",
        "Temperature Dependence of Resistance",
        "R"
    });
    
    formulas.push_back({
        "Temperature Dependence of Resistance (solve for alpha)",
        "\\alpha = \\frac{R - R_0}{R_0 \\Delta T}",
        {
            {"\\alpha", {0, 0, 0, 0, -1, 0, 0}, "Temperature coefficient", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance at temperature T", false},
            {"R_0", {2, -3, 1, -2, 0, 0, 0}, "Resistance at reference temperature", false},
            {"\\Delta T", {0, 0, 0, 0, 1, 0, 0}, "Temperature change", false}
        },
        "Circuits",
        "Temperature Dependence of Resistance",
        "\\alpha"
    });
    
    // ========================================================================
    // KIRCHHOFF'S CURRENT LAW (Junction Rule): Sum of currents = 0
    // ========================================================================
    
    formulas.push_back({
        "Kirchhoff's Current Law (conceptual)",
        "\\sum I_{in} = \\sum I_{out}",
        {
            {"\\sum I_{in}", {0, 0, 0, 1, 0, 0, 0}, "Sum of currents entering", false},
            {"\\sum I_{out}", {0, 0, 0, 1, 0, 0, 0}, "Sum of currents leaving", false}
        },
        "Circuits",
        "Kirchhoff's Current Law",
        "relationship"
    });
    
    // ========================================================================
    // KIRCHHOFF'S VOLTAGE LAW (Loop Rule): Sum of voltages = 0
    // ========================================================================
    
    formulas.push_back({
        "Kirchhoff's Voltage Law (conceptual)",
        "\\sum V = 0",
        {
            {"\\sum V", {2, -3, 1, -1, 0, 0, 0}, "Sum of voltage changes around loop", false}
        },
        "Circuits",
        "Kirchhoff's Voltage Law",
        "relationship"
    });
    
    // ========================================================================
    // EMF AND INTERNAL RESISTANCE: V = EMF - I * r
    // ========================================================================
    
    formulas.push_back({
        "EMF with Internal Resistance (solve for V)",
        "V = \\varepsilon - Ir",
        {
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Terminal voltage", false},
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "EMF", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"r", {2, -3, 1, -2, 0, 0, 0}, "Internal resistance", false}
        },
        "Circuits",
        "EMF with Internal Resistance",
        "V"
    });
    
    formulas.push_back({
        "EMF with Internal Resistance (solve for EMF)",
        "\\varepsilon = V + Ir",
        {
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "EMF", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Terminal voltage", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"r", {2, -3, 1, -2, 0, 0, 0}, "Internal resistance", false}
        },
        "Circuits",
        "EMF with Internal Resistance",
        "\\varepsilon"
    });
    
    formulas.push_back({
        "EMF with Internal Resistance (solve for I)",
        "I = \\frac{\\varepsilon - V}{r}",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "EMF", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Terminal voltage", false},
            {"r", {2, -3, 1, -2, 0, 0, 0}, "Internal resistance", false}
        },
        "Circuits",
        "EMF with Internal Resistance",
        "I"
    });
    
    formulas.push_back({
        "EMF with Internal Resistance (solve for r)",
        "r = \\frac{\\varepsilon - V}{I}",
        {
            {"r", {2, -3, 1, -2, 0, 0, 0}, "Internal resistance", false},
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "EMF", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Terminal voltage", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Circuits",
        "EMF with Internal Resistance",
        "r"
    });
    
    // ========================================================================
    // RC CIRCUIT CHARGING: Q = Q_max * (1 - e^(-t/RC))
    // ========================================================================
    
    formulas.push_back({
        "RC Charging (conceptual)",
        "Q(t) = Q_{max}(1 - e^{-t/RC})",
        {
            {"Q(t)", {0, 1, 0, 1, 0, 0, 0}, "Charge at time t", false},
            {"Q_{max}", {0, 1, 0, 1, 0, 0, 0}, "Maximum charge", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false}
        },
        "Circuits",
        "RC Charging",
        "Q(t)"
    });
    
    // ========================================================================
    // RC CIRCUIT DISCHARGING: Q = Q_0 * e^(-t/RC)
    // ========================================================================
    
    formulas.push_back({
        "RC Discharging (conceptual)",
        "Q(t) = Q_0 e^{-t/RC}",
        {
            {"Q(t)", {0, 1, 0, 1, 0, 0, 0}, "Charge at time t", false},
            {"Q_0", {0, 1, 0, 1, 0, 0, 0}, "Initial charge", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false}
        },
        "Circuits",
        "RC Discharging",
        "Q(t)"
    });
    
    // ========================================================================
    // EQUIVALENT RESISTANCE (3 RESISTORS IN SERIES)
    // ========================================================================
    
    formulas.push_back({
        "Three Resistors in Series (solve for R_total)",
        "R_{total} = R_1 + R_2 + R_3",
        {
            {"R_{total}", {2, -3, 1, -2, 0, 0, 0}, "Total resistance", false},
            {"R_1", {2, -3, 1, -2, 0, 0, 0}, "Resistance 1", false},
            {"R_2", {2, -3, 1, -2, 0, 0, 0}, "Resistance 2", false},
            {"R_3", {2, -3, 1, -2, 0, 0, 0}, "Resistance 3", false}
        },
        "Circuits",
        "Three Resistors in Series",
        "R_{total}"
    });
    
    // ========================================================================
    // EQUIVALENT RESISTANCE (3 RESISTORS IN PARALLEL)
    // ========================================================================
    
    formulas.push_back({
        "Three Resistors in Parallel (relationship)",
        "\\frac{1}{R_{total}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\frac{1}{R_3}",
        {
            {"R_{total}", {2, -3, 1, -2, 0, 0, 0}, "Total resistance", false},
            {"R_1", {2, -3, 1, -2, 0, 0, 0}, "Resistance 1", false},
            {"R_2", {2, -3, 1, -2, 0, 0, 0}, "Resistance 2", false},
            {"R_3", {2, -3, 1, -2, 0, 0, 0}, "Resistance 3", false}
        },
        "Circuits",
        "Three Resistors in Parallel",
        "R_{total}"
    });
    
    // ========================================================================
    // WHEATSTONE BRIDGE (BALANCED): R_1 / R_2 = R_3 / R_4
    // ========================================================================
    
    formulas.push_back({
        "Wheatstone Bridge Balanced (solve for R_4)",
        "R_4 = \\frac{R_2 R_3}{R_1}",
        {
            {"R_4", {2, -3, 1, -2, 0, 0, 0}, "Unknown resistance", false},
            {"R_1", {2, -3, 1, -2, 0, 0, 0}, "Resistance 1", false},
            {"R_2", {2, -3, 1, -2, 0, 0, 0}, "Resistance 2", false},
            {"R_3", {2, -3, 1, -2, 0, 0, 0}, "Resistance 3", false}
        },
        "Circuits",
        "Wheatstone Bridge Balanced",
        "R_4"
    });
}

} // namespace Physics
    
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_circular_motion() {
    
    // Already covered in Dynamics (centripetal force/acceleration)
    // Adding additional circular motion formulas
    
    // ========================================================================
    // ANGULAR DISPLACEMENT: theta = omega * t
    // ========================================================================
    
    formulas.push_back({
        "Angular Displacement (solve for theta)",
        "\\theta = \\omega t",
        {
            {"\\theta", {0, 0, 0, 0, 0, 0, 0}, "Angular displacement", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Circular Motion",
        "Angular Displacement",
        "\\theta"
    });
    
    formulas.push_back({
        "Angular Displacement (solve for omega)",
        "\\omega = \\frac{\\theta}{t}",
        {
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false},
            {"\\theta", {0, 0, 0, 0, 0, 0, 0}, "Angular displacement", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Circular Motion",
        "Angular Displacement",
        "\\omega"
    });
    
    formulas.push_back({
        "Angular Displacement (solve for t)",
        "t = \\frac{\\theta}{\\omega}",
        {
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false},
            {"\\theta", {0, 0, 0, 0, 0, 0, 0}, "Angular displacement", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false}
        },
        "Circular Motion",
        "Angular Displacement",
        "t"
    });
    
    // ========================================================================
    // PERIOD AND ANGULAR VELOCITY: T = 2*pi / omega
    // ========================================================================
    
    formulas.push_back({
        "Period from Angular Velocity (solve for T)",
        "T = \\frac{2\\pi}{\\omega}",
        {
            {"T", {0, 1, 0, 0, 0, 0, 0}, "Period", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false}
        },
        "Circular Motion",
        "Period from Angular Velocity",
        "T"
    });
    
    formulas.push_back({
        "Period from Angular Velocity (solve for omega)",
        "\\omega = \\frac{2\\pi}{T}",
        {
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false},
            {"T", {0, 1, 0, 0, 0, 0, 0}, "Period", false}
        },
        "Circular Motion",
        "Period from Angular Velocity",
        "\\omega"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_dynamics() {
    
    // ========================================================================
    // NEWTON'S SECOND LAW: F = m * a
    // ========================================================================
    
    formulas.push_back({
        "Newton's Second Law (solve for F)",
        "F = ma",
        {
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false}
        },
        "Dynamics",
        "Newton's Second Law",
        "F"
    });
    
    formulas.push_back({
        "Newton's Second Law (solve for m)",
        "m = \\frac{F}{a}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false}
        },
        "Dynamics",
        "Newton's Second Law",
        "m"
    });
    
    formulas.push_back({
        "Newton's Second Law (solve for a)",
        "a = \\frac{F}{m}",
        {
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false}
        },
        "Dynamics",
        "Newton's Second Law",
        "a"
    });
    
    // ========================================================================
    // WEIGHT: W = m * g
    // ========================================================================
    
    formulas.push_back({
        "Weight (solve for W)",
        "W = mg",
        {
            {"W", {1, -2, 1, 0, 0, 0, 0}, "Weight", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true}
        },
        "Dynamics",
        "Weight",
        "W"
    });
    
    formulas.push_back({
        "Weight (solve for m)",
        "m = \\frac{W}{g}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"W", {1, -2, 1, 0, 0, 0, 0}, "Weight", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true}
        },
        "Dynamics",
        "Weight",
        "m"
    });
    
    // ========================================================================
    // FRICTION FORCE: F_f = mu * N
    // ========================================================================
    
    formulas.push_back({
        "Friction Force (solve for F_f)",
        "F_f = \\mu N",
        {
            {"F_f", {1, -2, 1, 0, 0, 0, 0}, "Friction force", false},
            {"\\mu", {0, 0, 0, 0, 0, 0, 0}, "Coefficient of friction", false},
            {"N", {1, -2, 1, 0, 0, 0, 0}, "Normal force", false}
        },
        "Dynamics",
        "Friction Force",
        "F_f"
    });
    
    formulas.push_back({
        "Friction Force (solve for mu)",
        "\\mu = \\frac{F_f}{N}",
        {
            {"\\mu", {0, 0, 0, 0, 0, 0, 0}, "Coefficient of friction", false},
            {"F_f", {1, -2, 1, 0, 0, 0, 0}, "Friction force", false},
            {"N", {1, -2, 1, 0, 0, 0, 0}, "Normal force", false}
        },
        "Dynamics",
        "Friction Force",
        "\\mu"
    });
    
    formulas.push_back({
        "Friction Force (solve for N)",
        "N = \\frac{F_f}{\\mu}",
        {
            {"N", {1, -2, 1, 0, 0, 0, 0}, "Normal force", false},
            {"F_f", {1, -2, 1, 0, 0, 0, 0}, "Friction force", false},
            {"\\mu", {0, 0, 0, 0, 0, 0, 0}, "Coefficient of friction", false}
        },
        "Dynamics",
        "Friction Force",
        "N"
    });
    
    // ========================================================================
    // HOOKE'S LAW: F = k * x
    // ========================================================================
    
    formulas.push_back({
        "Hooke's Law (solve for F)",
        "F = kx",
        {
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Spring force", false},
            {"k", {0, -2, 1, 0, 0, 0, 0}, "Spring constant", false},
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Displacement", false}
        },
        "Dynamics",
        "Hooke's Law",
        "F"
    });
    
    formulas.push_back({
        "Hooke's Law (solve for k)",
        "k = \\frac{F}{x}",
        {
            {"k", {0, -2, 1, 0, 0, 0, 0}, "Spring constant", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Spring force", false},
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Displacement", false}
        },
        "Dynamics",
        "Hooke's Law",
        "k"
    });
    
    formulas.push_back({
        "Hooke's Law (solve for x)",
        "x = \\frac{F}{k}",
        {
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Displacement", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Spring force", false},
            {"k", {0, -2, 1, 0, 0, 0, 0}, "Spring constant", false}
        },
        "Dynamics",
        "Hooke's Law",
        "x"
    });
    
    // ========================================================================
    // WORK: W = F * d * cos(theta) (for theta = 0: W = F * d)
    // ========================================================================
    
    formulas.push_back({
        "Work (solve for W)",
        "W = Fd",
        {
            {"W", {2, -2, 1, 0, 0, 0, 0}, "Work", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Displacement", false}
        },
        "Dynamics",
        "Work",
        "W"
    });
    
    formulas.push_back({
        "Work (solve for F)",
        "F = \\frac{W}{d}",
        {
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"W", {2, -2, 1, 0, 0, 0, 0}, "Work", false},
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Displacement", false}
        },
        "Dynamics",
        "Work",
        "F"
    });
    
    formulas.push_back({
        "Work (solve for d)",
        "d = \\frac{W}{F}",
        {
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Displacement", false},
            {"W", {2, -2, 1, 0, 0, 0, 0}, "Work", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false}
        },
        "Dynamics",
        "Work",
        "d"
    });
    
    // ========================================================================
    // CENTRIPETAL FORCE: F_c = m * v^2 / r
    // ========================================================================
    
    formulas.push_back({
        "Centripetal Force (solve for F_c)",
        "F_c = \\frac{mv^2}{r}",
        {
            {"F_c", {1, -2, 1, 0, 0, 0, 0}, "Centripetal force", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false}
        },
        "Dynamics",
        "Centripetal Force",
        "F_c"
    });
    
    formulas.push_back({
        "Centripetal Force (solve for m)",
        "m = \\frac{F_c r}{v^2}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"F_c", {1, -2, 1, 0, 0, 0, 0}, "Centripetal force", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Dynamics",
        "Centripetal Force",
        "m"
    });
    
    formulas.push_back({
        "Centripetal Force (solve for v)",
        "v = \\sqrt{\\frac{F_c r}{m}}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"F_c", {1, -2, 1, 0, 0, 0, 0}, "Centripetal force", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false}
        },
        "Dynamics",
        "Centripetal Force",
        "v"
    });
    
    formulas.push_back({
        "Centripetal Force (solve for r)",
        "r = \\frac{mv^2}{F_c}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"F_c", {1, -2, 1, 0, 0, 0, 0}, "Centripetal force", false}
        },
        "Dynamics",
        "Centripetal Force",
        "r"
    });
    
    // ========================================================================
    // CENTRIPETAL ACCELERATION: a_c = v^2 / r
    // ========================================================================
    
    formulas.push_back({
        "Centripetal Acceleration (solve for a_c)",
        "a_c = \\frac{v^2}{r}",
        {
            {"a_c", {1, -2, 0, 0, 0, 0, 0}, "Centripetal acceleration", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false}
        },
        "Dynamics",
        "Centripetal Acceleration",
        "a_c"
    });
    
    formulas.push_back({
        "Centripetal Acceleration (solve for v)",
        "v = \\sqrt{a_c r}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"a_c", {1, -2, 0, 0, 0, 0, 0}, "Centripetal acceleration", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false}
        },
        "Dynamics",
        "Centripetal Acceleration",
        "v"
    });
    
    formulas.push_back({
        "Centripetal Acceleration (solve for r)",
        "r = \\frac{v^2}{a_c}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"a_c", {1, -2, 0, 0, 0, 0, 0}, "Centripetal acceleration", false}
        },
        "Dynamics",
        "Centripetal Acceleration",
        "r"
    });
    
    // ========================================================================
    // CENTRIPETAL FORCE (ANGULAR): F_c = m * omega^2 * r
    // ========================================================================
    
    formulas.push_back({
        "Centripetal Force Angular (solve for F_c)",
        "F_c = m\\omega^2 r",
        {
            {"F_c", {1, -2, 1, 0, 0, 0, 0}, "Centripetal force", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false}
        },
        "Dynamics",
        "Centripetal Force Angular",
        "F_c"
    });
    
    formulas.push_back({
        "Centripetal Force Angular (solve for m)",
        "m = \\frac{F_c}{\\omega^2 r}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"F_c", {1, -2, 1, 0, 0, 0, 0}, "Centripetal force", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false}
        },
        "Dynamics",
        "Centripetal Force Angular",
        "m"
    });
    
    formulas.push_back({
        "Centripetal Force Angular (solve for omega)",
        "\\omega = \\sqrt{\\frac{F_c}{mr}}",
        {
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false},
            {"F_c", {1, -2, 1, 0, 0, 0, 0}, "Centripetal force", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false}
        },
        "Dynamics",
        "Centripetal Force Angular",
        "\\omega"
    });
    
    formulas.push_back({
        "Centripetal Force Angular (solve for r)",
        "r = \\frac{F_c}{m\\omega^2}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"F_c", {1, -2, 1, 0, 0, 0, 0}, "Centripetal force", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false}
        },
        "Dynamics",
        "Centripetal Force Angular",
        "r"
    });
    
    // ========================================================================
    // IMPULSE: J = F * Delta_t
    // ========================================================================
    
    formulas.push_back({
        "Impulse (solve for J)",
        "J = F\\Delta t",
        {
            {"J", {1, -1, 1, 0, 0, 0, 0}, "Impulse", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"\\Delta t", {0, 1, 0, 0, 0, 0, 0}, "Time interval", false}
        },
        "Dynamics",
        "Impulse",
        "J"
    });
    
    formulas.push_back({
        "Impulse (solve for F)",
        "F = \\frac{J}{\\Delta t}",
        {
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"J", {1, -1, 1, 0, 0, 0, 0}, "Impulse", false},
            {"\\Delta t", {0, 1, 0, 0, 0, 0, 0}, "Time interval", false}
        },
        "Dynamics",
        "Impulse",
        "F"
    });
    
    formulas.push_back({
        "Impulse (solve for Delta_t)",
        "\\Delta t = \\frac{J}{F}",
        {
            {"\\Delta t", {0, 1, 0, 0, 0, 0, 0}, "Time interval", false},
            {"J", {1, -1, 1, 0, 0, 0, 0}, "Impulse", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false}
        },
        "Dynamics",
        "Impulse",
        "\\Delta t"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_electromagnetic_waves() {
    
    // ========================================================================
    // SPEED OF LIGHT: c = f * lambda
    // ========================================================================
    
    formulas.push_back({
        "Speed of Light (solve for c)",
        "c = f\\lambda",
        {
            {"c", {1, -1, 0, 0, 0, 0, 0}, "Speed of light", true},
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"\\lambda", {1, 0, 0, 0, 0, 0, 0}, "Wavelength", false}
        },
        "Electromagnetic Waves",
        "Speed of Light",
        "c"
    });
    
    formulas.push_back({
        "Speed of Light (solve for f)",
        "f = \\frac{c}{\\lambda}",
        {
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"c", {1, -1, 0, 0, 0, 0, 0}, "Speed of light", true},
            {"\\lambda", {1, 0, 0, 0, 0, 0, 0}, "Wavelength", false}
        },
        "Electromagnetic Waves",
        "Speed of Light",
        "f"
    });
    
    formulas.push_back({
        "Speed of Light (solve for lambda)",
        "\\lambda = \\frac{c}{f}",
        {
            {"\\lambda", {1, 0, 0, 0, 0, 0, 0}, "Wavelength", false},
            {"c", {1, -1, 0, 0, 0, 0, 0}, "Speed of light", true},
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false}
        },
        "Electromagnetic Waves",
        "Speed of Light",
        "\\lambda"
    });
    
    // ========================================================================
    // ELECTROMAGNETIC WAVE SPEED IN MEDIUM: v = c / n
    // ========================================================================
    
    formulas.push_back({
        "EM Wave Speed in Medium (solve for v)",
        "v = \\frac{c}{n}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Wave speed in medium", false},
            {"c", {1, -1, 0, 0, 0, 0, 0}, "Speed of light in vacuum", true},
            {"n", {0, 0, 0, 0, 0, 0, 0}, "Index of refraction", false}
        },
        "Electromagnetic Waves",
        "EM Wave Speed in Medium",
        "v"
    });
    
    formulas.push_back({
        "EM Wave Speed in Medium (solve for n)",
        "n = \\frac{c}{v}",
        {
            {"n", {0, 0, 0, 0, 0, 0, 0}, "Index of refraction", false},
            {"c", {1, -1, 0, 0, 0, 0, 0}, "Speed of light in vacuum", true},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Wave speed in medium", false}
        },
        "Electromagnetic Waves",
        "EM Wave Speed in Medium",
        "n"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_electrostatics() {
    
    // ========================================================================
    // COULOMB'S LAW: F = k * q1 * q2 / r^2
    // ========================================================================
    
    formulas.push_back({
        "Coulomb's Law (solve for F)",
        "F = k \\frac{q_1 q_2}{r^2}",
        {
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true},
            {"q_1", {0, 1, 0, 1, 0, 0, 0}, "Charge 1", false},
            {"q_2", {0, 1, 0, 1, 0, 0, 0}, "Charge 2", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false}
        },
        "Electrostatics",
        "Coulomb's Law",
        "F"
    });
    
    formulas.push_back({
        "Coulomb's Law (solve for q_1)",
        "q_1 = \\frac{F r^2}{k q_2}",
        {
            {"q_1", {0, 1, 0, 1, 0, 0, 0}, "Charge 1", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true},
            {"q_2", {0, 1, 0, 1, 0, 0, 0}, "Charge 2", false}
        },
        "Electrostatics",
        "Coulomb's Law",
        "q_1"
    });
    
    formulas.push_back({
        "Coulomb's Law (solve for q_2)",
        "q_2 = \\frac{F r^2}{k q_1}",
        {
            {"q_2", {0, 1, 0, 1, 0, 0, 0}, "Charge 2", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true},
            {"q_1", {0, 1, 0, 1, 0, 0, 0}, "Charge 1", false}
        },
        "Electrostatics",
        "Coulomb's Law",
        "q_2"
    });
    
    formulas.push_back({
        "Coulomb's Law (solve for r)",
        "r = \\sqrt{\\frac{k q_1 q_2}{F}}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true},
            {"q_1", {0, 1, 0, 1, 0, 0, 0}, "Charge 1", false},
            {"q_2", {0, 1, 0, 1, 0, 0, 0}, "Charge 2", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false}
        },
        "Electrostatics",
        "Coulomb's Law",
        "r"
    });
    
    // ========================================================================
    // ELECTRIC FIELD FROM FORCE: E = F / q
    // ========================================================================
    
    formulas.push_back({
        "Electric Field from Force (solve for E)",
        "E = \\frac{F}{q}",
        {
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false}
        },
        "Electrostatics",
        "Electric Field from Force",
        "E"
    });
    
    formulas.push_back({
        "Electric Field from Force (solve for F)",
        "F = Eq",
        {
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false}
        },
        "Electrostatics",
        "Electric Field from Force",
        "F"
    });
    
    formulas.push_back({
        "Electric Field from Force (solve for q)",
        "q = \\frac{F}{E}",
        {
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false}
        },
        "Electrostatics",
        "Electric Field from Force",
        "q"
    });
    
    // ========================================================================
    // ELECTRIC FIELD FROM POINT CHARGE: E = k * q / r^2
    // ========================================================================
    
    formulas.push_back({
        "Electric Field Point Charge (solve for E)",
        "E = k \\frac{q}{r^2}",
        {
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false}
        },
        "Electrostatics",
        "Electric Field Point Charge",
        "E"
    });
    
    formulas.push_back({
        "Electric Field Point Charge (solve for q)",
        "q = \\frac{E r^2}{k}",
        {
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true}
        },
        "Electrostatics",
        "Electric Field Point Charge",
        "q"
    });
    
    formulas.push_back({
        "Electric Field Point Charge (solve for r)",
        "r = \\sqrt{\\frac{kq}{E}}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false}
        },
        "Electrostatics",
        "Electric Field Point Charge",
        "r"
    });
    
    // ========================================================================
    // ELECTRIC POTENTIAL: V = k * q / r
    // ========================================================================
    
    formulas.push_back({
        "Electric Potential Point Charge (solve for V)",
        "V = k \\frac{q}{r}",
        {
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Electric potential", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false}
        },
        "Electrostatics",
        "Electric Potential Point Charge",
        "V"
    });
    
    formulas.push_back({
        "Electric Potential Point Charge (solve for q)",
        "q = \\frac{Vr}{k}",
        {
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Electric potential", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true}
        },
        "Electrostatics",
        "Electric Potential Point Charge",
        "q"
    });
    
    formulas.push_back({
        "Electric Potential Point Charge (solve for r)",
        "r = \\frac{kq}{V}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Electric potential", false}
        },
        "Electrostatics",
        "Electric Potential Point Charge",
        "r"
    });
    
    // ========================================================================
    // ELECTRIC FIELD FROM POTENTIAL: E = V / d
    // ========================================================================
    
    formulas.push_back({
        "Electric Field from Potential (solve for E)",
        "E = \\frac{V}{d}",
        {
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Potential difference", false},
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Distance", false}
        },
        "Electrostatics",
        "Electric Field from Potential",
        "E"
    });
    
    formulas.push_back({
        "Electric Field from Potential (solve for V)",
        "V = Ed",
        {
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Potential difference", false},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Distance", false}
        },
        "Electrostatics",
        "Electric Field from Potential",
        "V"
    });
    
    formulas.push_back({
        "Electric Field from Potential (solve for d)",
        "d = \\frac{V}{E}",
        {
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Potential difference", false},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false}
        },
        "Electrostatics",
        "Electric Field from Potential",
        "d"
    });
    
    // ========================================================================
    // ELECTRIC POTENTIAL ENERGY: U = k * q1 * q2 / r
    // ========================================================================
    
    formulas.push_back({
        "Electric Potential Energy (solve for U)",
        "U = k \\frac{q_1 q_2}{r}",
        {
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true},
            {"q_1", {0, 1, 0, 1, 0, 0, 0}, "Charge 1", false},
            {"q_2", {0, 1, 0, 1, 0, 0, 0}, "Charge 2", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false}
        },
        "Electrostatics",
        "Electric Potential Energy",
        "U"
    });
    
    formulas.push_back({
        "Electric Potential Energy (solve for q_1)",
        "q_1 = \\frac{Ur}{k q_2}",
        {
            {"q_1", {0, 1, 0, 1, 0, 0, 0}, "Charge 1", false},
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true},
            {"q_2", {0, 1, 0, 1, 0, 0, 0}, "Charge 2", false}
        },
        "Electrostatics",
        "Electric Potential Energy",
        "q_1"
    });
    
    formulas.push_back({
        "Electric Potential Energy (solve for r)",
        "r = k \\frac{q_1 q_2}{U}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"k", {3, -4, 1, -2, 0, 0, 0}, "Coulomb's constant", true},
            {"q_1", {0, 1, 0, 1, 0, 0, 0}, "Charge 1", false},
            {"q_2", {0, 1, 0, 1, 0, 0, 0}, "Charge 2", false},
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false}
        },
        "Electrostatics",
        "Electric Potential Energy",
        "r"
    });
    
    // ========================================================================
    // CAPACITANCE: C = Q / V
    // ========================================================================
    
    formulas.push_back({
        "Capacitance (solve for C)",
        "C = \\frac{Q}{V}",
        {
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false}
        },
        "Electrostatics",
        "Capacitance",
        "C"
    });
    
    formulas.push_back({
        "Capacitance (solve for Q)",
        "Q = CV",
        {
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false}
        },
        "Electrostatics",
        "Capacitance",
        "Q"
    });
    
    formulas.push_back({
        "Capacitance (solve for V)",
        "V = \\frac{Q}{C}",
        {
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false}
        },
        "Electrostatics",
        "Capacitance",
        "V"
    });
    
    // ========================================================================
    // PARALLEL PLATE CAPACITOR: C = epsilon_0 * A / d
    // ========================================================================
    
    formulas.push_back({
        "Parallel Plate Capacitor (solve for C)",
        "C = \\epsilon_0 \\frac{A}{d}",
        {
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false},
            {"\\epsilon_0", {-3, 4, -1, 2, 0, 0, 0}, "Permittivity of free space", true},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false},
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Distance", false}
        },
        "Electrostatics",
        "Parallel Plate Capacitor",
        "C"
    });
    
    formulas.push_back({
        "Parallel Plate Capacitor (solve for A)",
        "A = \\frac{Cd}{\\epsilon_0}",
        {
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false},
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"\\epsilon_0", {-3, 4, -1, 2, 0, 0, 0}, "Permittivity of free space", true}
        },
        "Electrostatics",
        "Parallel Plate Capacitor",
        "A"
    });
    
    formulas.push_back({
        "Parallel Plate Capacitor (solve for d)",
        "d = \\epsilon_0 \\frac{A}{C}",
        {
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"\\epsilon_0", {-3, 4, -1, 2, 0, 0, 0}, "Permittivity of free space", true},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false}
        },
        "Electrostatics",
        "Parallel Plate Capacitor",
        "d"
    });
    
    // ========================================================================
    // CAPACITOR ENERGY: U = (1/2) * C * V^2
    // ========================================================================
    
    formulas.push_back({
        "Capacitor Energy (solve for U)",
        "U = \\frac{1}{2} C V^2",
        {
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false}
        },
        "Electrostatics",
        "Capacitor Energy",
        "U"
    });
    
    formulas.push_back({
        "Capacitor Energy (solve for C)",
        "C = \\frac{2U}{V^2}",
        {
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false},
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false}
        },
        "Electrostatics",
        "Capacitor Energy",
        "C"
    });
    
    formulas.push_back({
        "Capacitor Energy (solve for V)",
        "V = \\sqrt{\\frac{2U}{C}}",
        {
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Voltage", false},
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false}
        },
        "Electrostatics",
        "Capacitor Energy",
        "V"
    });
    
    // ========================================================================
    // CAPACITOR ENERGY FROM CHARGE: U = Q^2 / (2C)
    // ========================================================================
    
    formulas.push_back({
        "Capacitor Energy from Charge (solve for U)",
        "U = \\frac{Q^2}{2C}",
        {
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false}
        },
        "Electrostatics",
        "Capacitor Energy from Charge",
        "U"
    });
    
    formulas.push_back({
        "Capacitor Energy from Charge (solve for Q)",
        "Q = \\sqrt{2UC}",
        {
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false}
        },
        "Electrostatics",
        "Capacitor Energy from Charge",
        "Q"
    });
    
    formulas.push_back({
        "Capacitor Energy from Charge (solve for C)",
        "C = \\frac{Q^2}{2U}",
        {
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Energy", false}
        },
        "Electrostatics",
        "Capacitor Energy from Charge",
        "C"
    });
    
    // ========================================================================
    // CAPACITORS IN PARALLEL: C_total = C_1 + C_2
    // ========================================================================
    
    formulas.push_back({
        "Capacitors in Parallel (solve for C_total)",
        "C_{total} = C_1 + C_2",
        {
            {"C_{total}", {-2, 4, -1, 2, 0, 0, 0}, "Total capacitance", false},
            {"C_1", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance 1", false},
            {"C_2", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance 2", false}
        },
        "Electrostatics",
        "Capacitors in Parallel",
        "C_{total}"
    });
    
    formulas.push_back({
        "Capacitors in Parallel (solve for C_1)",
        "C_1 = C_{total} - C_2",
        {
            {"C_1", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance 1", false},
            {"C_{total}", {-2, 4, -1, 2, 0, 0, 0}, "Total capacitance", false},
            {"C_2", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance 2", false}
        },
        "Electrostatics",
        "Capacitors in Parallel",
        "C_1"
    });
    // ========================================================================
    // CAPACITANCE WITH DIELECTRIC: C = kappa * C_0
    // ========================================================================
    
    formulas.push_back({
        "Capacitance with Dielectric (solve for C)",
        "C = \\kappa C_0",
        {
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance with dielectric", false},
            {"\\kappa", {0, 0, 0, 0, 0, 0, 0}, "Dielectric constant", false},
            {"C_0", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance without dielectric", false}
        },
        "Electrostatics",
        "Capacitance with Dielectric",
        "C"
    });
    
    formulas.push_back({
        "Capacitance with Dielectric (solve for kappa)",
        "\\kappa = \\frac{C}{C_0}",
        {
            {"\\kappa", {0, 0, 0, 0, 0, 0, 0}, "Dielectric constant", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance with dielectric", false},
            {"C_0", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance without dielectric", false}
        },
        "Electrostatics",
        "Capacitance with Dielectric",
        "\\kappa"
    });
    
    formulas.push_back({
        "Capacitance with Dielectric (solve for C_0)",
        "C_0 = \\frac{C}{\\kappa}",
        {
            {"C_0", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance without dielectric", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance with dielectric", false},
            {"\\kappa", {0, 0, 0, 0, 0, 0, 0}, "Dielectric constant", false}
        },
        "Electrostatics",
        "Capacitance with Dielectric",
        "C_0"
    });
    
    // ========================================================================
    // ELECTRIC FIELD IN DIELECTRIC: E = E_0 / kappa
    // ========================================================================
    
    formulas.push_back({
        "Electric Field in Dielectric (solve for E)",
        "E = \\frac{E_0}{\\kappa}",
        {
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field in dielectric", false},
            {"E_0", {1, -3, 1, -1, 0, 0, 0}, "Electric field in vacuum", false},
            {"\\kappa", {0, 0, 0, 0, 0, 0, 0}, "Dielectric constant", false}
        },
        "Electrostatics",
        "Electric Field in Dielectric",
        "E"
    });
    
    formulas.push_back({
        "Electric Field in Dielectric (solve for E_0)",
        "E_0 = \\kappa E",
        {
            {"E_0", {1, -3, 1, -1, 0, 0, 0}, "Electric field in vacuum", false},
            {"\\kappa", {0, 0, 0, 0, 0, 0, 0}, "Dielectric constant", false},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field in dielectric", false}
        },
        "Electrostatics",
        "Electric Field in Dielectric",
        "E_0"
    });
    
    formulas.push_back({
        "Electric Field in Dielectric (solve for kappa)",
        "\\kappa = \\frac{E_0}{E}",
        {
            {"\\kappa", {0, 0, 0, 0, 0, 0, 0}, "Dielectric constant", false},
            {"E_0", {1, -3, 1, -1, 0, 0, 0}, "Electric field in vacuum", false},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field in dielectric", false}
        },
        "Electrostatics",
        "Electric Field in Dielectric",
        "\\kappa"
    });
    
    // ========================================================================
    // ENERGY DENSITY IN ELECTRIC FIELD: u = (1/2) * epsilon_0 * E^2
    // ========================================================================
    
    formulas.push_back({
        "Electric Energy Density (solve for u)",
        "u = \\frac{1}{2}\\epsilon_0 E^2",
        {
            {"u", {-1, -2, 1, 0, 0, 0, 0}, "Energy density", false},
            {"\\epsilon_0", {-3, 4, -1, 2, 0, 0, 0}, "Permittivity of free space", true},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false}
        },
        "Electrostatics",
        "Electric Energy Density",
        "u"
    });
    
    formulas.push_back({
        "Electric Energy Density (solve for E)",
        "E = \\sqrt{\\frac{2u}{\\epsilon_0}}",
        {
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"u", {-1, -2, 1, 0, 0, 0, 0}, "Energy density", false},
            {"\\epsilon_0", {-3, 4, -1, 2, 0, 0, 0}, "Permittivity of free space", true}
        },
        "Electrostatics",
        "Electric Energy Density",
        "E"
    });
    
    // ========================================================================
    // ELECTRIC DIPOLE MOMENT: p = q * d
    // ========================================================================
    
    formulas.push_back({
        "Electric Dipole Moment (solve for p)",
        "p = qd",
        {
            {"p", {1, 1, 0, 1, 0, 0, 0}, "Dipole moment", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Separation distance", false}
        },
        "Electrostatics",
        "Electric Dipole Moment",
        "p"
    });
    
    formulas.push_back({
        "Electric Dipole Moment (solve for q)",
        "q = \\frac{p}{d}",
        {
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"p", {1, 1, 0, 1, 0, 0, 0}, "Dipole moment", false},
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Separation distance", false}
        },
        "Electrostatics",
        "Electric Dipole Moment",
        "q"
    });
    
    formulas.push_back({
        "Electric Dipole Moment (solve for d)",
        "d = \\frac{p}{q}",
        {
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Separation distance", false},
            {"p", {1, 1, 0, 1, 0, 0, 0}, "Dipole moment", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false}
        },
        "Electrostatics",
        "Electric Dipole Moment",
        "d"
    });
    
    // ========================================================================
    // ELECTRIC FLUX: Phi = E * A (for uniform field perpendicular to surface)
    // ========================================================================
    
    formulas.push_back({
        "Electric Flux (solve for Phi)",
        "\\Phi_E = EA",
        {
            {"\\Phi_E", {3, -3, 1, -1, 0, 0, 0}, "Electric flux", false},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false}
        },
        "Electrostatics",
        "Electric Flux",
        "\\Phi_E"
    });
    
    formulas.push_back({
        "Electric Flux (solve for E)",
        "E = \\frac{\\Phi_E}{A}",
        {
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"\\Phi_E", {3, -3, 1, -1, 0, 0, 0}, "Electric flux", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false}
        },
        "Electrostatics",
        "Electric Flux",
        "E"
    });
    
    formulas.push_back({
        "Electric Flux (solve for A)",
        "A = \\frac{\\Phi_E}{E}",
        {
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false},
            {"\\Phi_E", {3, -3, 1, -1, 0, 0, 0}, "Electric flux", false},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false}
        },
        "Electrostatics",
        "Electric Flux",
        "A"
    });
    
    // ========================================================================
    // GAUSS'S LAW: Phi = Q_enclosed / epsilon_0
    // ========================================================================
    
    formulas.push_back({
        "Gauss's Law (solve for Phi)",
        "\\Phi_E = \\frac{Q_{enc}}{\\epsilon_0}",
        {
            {"\\Phi_E", {3, -3, 1, -1, 0, 0, 0}, "Electric flux", false},
            {"Q_{enc}", {0, 1, 0, 1, 0, 0, 0}, "Enclosed charge", false},
            {"\\epsilon_0", {-3, 4, -1, 2, 0, 0, 0}, "Permittivity of free space", true}
        },
        "Electrostatics",
        "Gauss's Law",
        "\\Phi_E"
    });
    
    formulas.push_back({
        "Gauss's Law (solve for Q_enc)",
        "Q_{enc} = \\epsilon_0 \\Phi_E",
        {
            {"Q_{enc}", {0, 1, 0, 1, 0, 0, 0}, "Enclosed charge", false},
            {"\\epsilon_0", {-3, 4, -1, 2, 0, 0, 0}, "Permittivity of free space", true},
            {"\\Phi_E", {3, -3, 1, -1, 0, 0, 0}, "Electric flux", false}
        },
        "Electrostatics",
        "Gauss's Law",
        "Q_{enc}"
    });
    
    // ========================================================================
    // SURFACE CHARGE DENSITY: sigma = Q / A
    // ========================================================================
    
    formulas.push_back({
        "Surface Charge Density (solve for sigma)",
        "\\sigma = \\frac{Q}{A}",
        {
            {"\\sigma", {-2, 1, 0, 1, 0, 0, 0}, "Surface charge density", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false}
        },
        "Electrostatics",
        "Surface Charge Density",
        "\\sigma"
    });
    
    formulas.push_back({
        "Surface Charge Density (solve for Q)",
        "Q = \\sigma A",
        {
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"\\sigma", {-2, 1, 0, 1, 0, 0, 0}, "Surface charge density", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false}
        },
        "Electrostatics",
        "Surface Charge Density",
        "Q"
    });
    
    formulas.push_back({
        "Surface Charge Density (solve for A)",
        "A = \\frac{Q}{\\sigma}",
        {
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"\\sigma", {-2, 1, 0, 1, 0, 0, 0}, "Surface charge density", false}
        },
        "Electrostatics",
        "Surface Charge Density",
        "A"
    });
    
    // ========================================================================
    // LINEAR CHARGE DENSITY: lambda = Q / L
    // ========================================================================
    
    formulas.push_back({
        "Linear Charge Density (solve for lambda)",
        "\\lambda = \\frac{Q}{L}",
        {
            {"\\lambda", {-1, 1, 0, 1, 0, 0, 0}, "Linear charge density", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false}
        },
        "Electrostatics",
        "Linear Charge Density",
        "\\lambda"
    });
    
    formulas.push_back({
        "Linear Charge Density (solve for Q)",
        "Q = \\lambda L",
        {
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"\\lambda", {-1, 1, 0, 1, 0, 0, 0}, "Linear charge density", false},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false}
        },
        "Electrostatics",
        "Linear Charge Density",
        "Q"
    });
    
    formulas.push_back({
        "Linear Charge Density (solve for L)",
        "L = \\frac{Q}{\\lambda}",
        {
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"\\lambda", {-1, 1, 0, 1, 0, 0, 0}, "Linear charge density", false}
        },
        "Electrostatics",
        "Linear Charge Density",
        "L"
    });
    
    // ========================================================================
    // VOLUME CHARGE DENSITY: rho = Q / V
    // ========================================================================
    
    formulas.push_back({
        "Volume Charge Density (solve for rho)",
        "\\rho_q = \\frac{Q}{V}",
        {
            {"\\rho_q", {-3, 1, 0, 1, 0, 0, 0}, "Volume charge density", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false}
        },
        "Electrostatics",
        "Volume Charge Density",
        "\\rho_q"
    });
    
    formulas.push_back({
        "Volume Charge Density (solve for Q)",
        "Q = \\rho_q V",
        {
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"\\rho_q", {-3, 1, 0, 1, 0, 0, 0}, "Volume charge density", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false}
        },
        "Electrostatics",
        "Volume Charge Density",
        "Q"
    });
    
    formulas.push_back({
        "Volume Charge Density (solve for V)",
        "V = \\frac{Q}{\\rho_q}",
        {
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false},
            {"Q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"\\rho_q", {-3, 1, 0, 1, 0, 0, 0}, "Volume charge density", false}
        },
        "Electrostatics",
        "Volume Charge Density",
        "V"
    });
    
    // ========================================================================
    // ELECTRIC FIELD OF INFINITE PLANE: E = sigma / (2 * epsilon_0)
    // ========================================================================
    
    formulas.push_back({
        "Electric Field of Infinite Plane (solve for E)",
        "E = \\frac{\\sigma}{2\\epsilon_0}",
        {
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"\\sigma", {-2, 1, 0, 1, 0, 0, 0}, "Surface charge density", false},
            {"\\epsilon_0", {-3, 4, -1, 2, 0, 0, 0}, "Permittivity of free space", true}
        },
        "Electrostatics",
        "Electric Field of Infinite Plane",
        "E"
    });
    
    formulas.push_back({
        "Electric Field of Infinite Plane (solve for sigma)",
        "\\sigma = 2\\epsilon_0 E",
        {
            {"\\sigma", {-2, 1, 0, 1, 0, 0, 0}, "Surface charge density", false},
            {"\\epsilon_0", {-3, 4, -1, 2, 0, 0, 0}, "Permittivity of free space", true},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false}
        },
        "Electrostatics",
        "Electric Field of Infinite Plane",
        "\\sigma"
    });
    
    // ========================================================================
    // SPHERICAL CAPACITOR: C = 4 * pi * epsilon_0 * (r_a * r_b) / (r_b - r_a)
    // ========================================================================
    
    formulas.push_back({
        "Spherical Capacitor (solve for C)",
        "C = 4\\pi\\epsilon_0 \\frac{r_a r_b}{r_b - r_a}",
        {
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false},
            {"\\epsilon_0", {-3, 4, -1, 2, 0, 0, 0}, "Permittivity of free space", true},
            {"r_a", {1, 0, 0, 0, 0, 0, 0}, "Inner radius", false},
            {"r_b", {1, 0, 0, 0, 0, 0, 0}, "Outer radius", false}
        },
        "Electrostatics",
        "Spherical Capacitor",
        "C"
    });
    
    // ========================================================================
    // CYLINDRICAL CAPACITOR: C = 2 * pi * epsilon_0 * L / ln(r_b / r_a)
    // ========================================================================
    
    formulas.push_back({
        "Cylindrical Capacitor (solve for C)",
        "C = \\frac{2\\pi\\epsilon_0 L}{\\ln(r_b/r_a)}",
        {
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false},
            {"\\epsilon_0", {-3, 4, -1, 2, 0, 0, 0}, "Permittivity of free space", true},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false},
            {"r_a", {1, 0, 0, 0, 0, 0, 0}, "Inner radius", false},
            {"r_b", {1, 0, 0, 0, 0, 0, 0}, "Outer radius", false}
        },
        "Electrostatics",
        "Cylindrical Capacitor",
        "C"
    });
}

} // namespace Physics
    
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_energy() {
    
    // ========================================================================
    // KINETIC ENERGY: KE = (1/2) * m * v^2
    // ========================================================================
    
    formulas.push_back({
        "Kinetic Energy (solve for KE)",
        "KE = \\frac{1}{2}mv^2",
        {
            {"KE", {2, -2, 1, 0, 0, 0, 0}, "Kinetic energy", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Energy",
        "Kinetic Energy",
        "KE"
    });
    
    formulas.push_back({
        "Kinetic Energy (solve for m)",
        "m = \\frac{2KE}{v^2}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"KE", {2, -2, 1, 0, 0, 0, 0}, "Kinetic energy", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Energy",
        "Kinetic Energy",
        "m"
    });
    
    formulas.push_back({
        "Kinetic Energy (solve for v)",
        "v = \\sqrt{\\frac{2KE}{m}}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"KE", {2, -2, 1, 0, 0, 0, 0}, "Kinetic energy", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false}
        },
        "Energy",
        "Kinetic Energy",
        "v"
    });
    
    // ========================================================================
    // GRAVITATIONAL POTENTIAL ENERGY: PE = m * g * h
    // ========================================================================
    
    formulas.push_back({
        "Gravitational Potential Energy (solve for PE)",
        "PE = mgh",
        {
            {"PE", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true},
            {"h", {1, 0, 0, 0, 0, 0, 0}, "Height", false}
        },
        "Energy",
        "Gravitational Potential Energy",
        "PE"
    });
    
    formulas.push_back({
        "Gravitational Potential Energy (solve for m)",
        "m = \\frac{PE}{gh}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"PE", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true},
            {"h", {1, 0, 0, 0, 0, 0, 0}, "Height", false}
        },
        "Energy",
        "Gravitational Potential Energy",
        "m"
    });
    
    formulas.push_back({
        "Gravitational Potential Energy (solve for h)",
        "h = \\frac{PE}{mg}",
        {
            {"h", {1, 0, 0, 0, 0, 0, 0}, "Height", false},
            {"PE", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true}
        },
        "Energy",
        "Gravitational Potential Energy",
        "h"
    });
    
    // ========================================================================
    // ELASTIC POTENTIAL ENERGY: PE_spring = (1/2) * k * x^2
    // ========================================================================
    
    formulas.push_back({
        "Elastic Potential Energy (solve for PE)",
        "PE = \\frac{1}{2}kx^2",
        {
            {"PE", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false},
            {"k", {0, -2, 1, 0, 0, 0, 0}, "Spring constant", false},
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Displacement", false}
        },
        "Energy",
        "Elastic Potential Energy",
        "PE"
    });
    
    formulas.push_back({
        "Elastic Potential Energy (solve for k)",
        "k = \\frac{2PE}{x^2}",
        {
            {"k", {0, -2, 1, 0, 0, 0, 0}, "Spring constant", false},
            {"PE", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false},
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Displacement", false}
        },
        "Energy",
        "Elastic Potential Energy",
        "k"
    });
    
    formulas.push_back({
        "Elastic Potential Energy (solve for x)",
        "x = \\sqrt{\\frac{2PE}{k}}",
        {
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Displacement", false},
            {"PE", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false},
            {"k", {0, -2, 1, 0, 0, 0, 0}, "Spring constant", false}
        },
        "Energy",
        "Elastic Potential Energy",
        "x"
    });
    
    // ========================================================================
    // WORK-ENERGY THEOREM: W = Delta_KE
    // ========================================================================
    
    formulas.push_back({
        "Work-Energy Theorem (solve for W)",
        "W = \\Delta KE",
        {
            {"W", {2, -2, 1, 0, 0, 0, 0}, "Work", false},
            {"\\Delta KE", {2, -2, 1, 0, 0, 0, 0}, "Change in kinetic energy", false}
        },
        "Energy",
        "Work-Energy Theorem",
        "W"
    });
    
    formulas.push_back({
        "Work-Energy Theorem (solve for Delta_KE)",
        "\\Delta KE = W",
        {
            {"\\Delta KE", {2, -2, 1, 0, 0, 0, 0}, "Change in kinetic energy", false},
            {"W", {2, -2, 1, 0, 0, 0, 0}, "Work", false}
        },
        "Energy",
        "Work-Energy Theorem",
        "\\Delta KE"
    });
    
    // ========================================================================
    // MECHANICAL ENERGY CONSERVATION: E = KE + PE
    // ========================================================================
    
    formulas.push_back({
        "Mechanical Energy (solve for E)",
        "E = KE + PE",
        {
            {"E", {2, -2, 1, 0, 0, 0, 0}, "Total mechanical energy", false},
            {"KE", {2, -2, 1, 0, 0, 0, 0}, "Kinetic energy", false},
            {"PE", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false}
        },
        "Energy",
        "Mechanical Energy",
        "E"
    });
    
    formulas.push_back({
        "Mechanical Energy (solve for KE)",
        "KE = E - PE",
        {
            {"KE", {2, -2, 1, 0, 0, 0, 0}, "Kinetic energy", false},
            {"E", {2, -2, 1, 0, 0, 0, 0}, "Total mechanical energy", false},
            {"PE", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false}
        },
        "Energy",
        "Mechanical Energy",
        "KE"
    });
    
    formulas.push_back({
        "Mechanical Energy (solve for PE)",
        "PE = E - KE",
        {
            {"PE", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false},
            {"E", {2, -2, 1, 0, 0, 0, 0}, "Total mechanical energy", false},
            {"KE", {2, -2, 1, 0, 0, 0, 0}, "Kinetic energy", false}
        },
        "Energy",
        "Mechanical Energy",
        "PE"
    });
    
    // ========================================================================
    // POWER: P = W / t
    // ========================================================================
    
    formulas.push_back({
        "Power from Work (solve for P)",
        "P = \\frac{W}{t}",
        {
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"W", {2, -2, 1, 0, 0, 0, 0}, "Work", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Energy",
        "Power from Work",
        "P"
    });
    
    formulas.push_back({
        "Power from Work (solve for W)",
        "W = Pt",
        {
            {"W", {2, -2, 1, 0, 0, 0, 0}, "Work", false},
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Energy",
        "Power from Work",
        "W"
    });
    
    formulas.push_back({
        "Power from Work (solve for t)",
        "t = \\frac{W}{P}",
        {
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false},
            {"W", {2, -2, 1, 0, 0, 0, 0}, "Work", false},
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false}
        },
        "Energy",
        "Power from Work",
        "t"
    });
    
    // ========================================================================
    // POWER: P = F * v
    // ========================================================================
    
    formulas.push_back({
        "Power from Force (solve for P)",
        "P = Fv",
        {
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Energy",
        "Power from Force",
        "P"
    });
    
    formulas.push_back({
        "Power from Force (solve for F)",
        "F = \\frac{P}{v}",
        {
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Energy",
        "Power from Force",
        "F"
    });
    
    formulas.push_back({
        "Power from Force (solve for v)",
        "v = \\frac{P}{F}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"P", {2, -3, 1, 0, 0, 0, 0}, "Power", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false}
        },
        "Energy",
        "Power from Force",
        "v"
    });
    
    // ========================================================================
    // EFFICIENCY: eta = W_out / W_in
    // ========================================================================
    
    formulas.push_back({
        "Efficiency (solve for eta)",
        "\\eta = \\frac{W_{out}}{W_{in}}",
        {
            {"\\eta", {0, 0, 0, 0, 0, 0, 0}, "Efficiency", false},
            {"W_{out}", {2, -2, 1, 0, 0, 0, 0}, "Work output", false},
            {"W_{in}", {2, -2, 1, 0, 0, 0, 0}, "Work input", false}
        },
        "Energy",
        "Efficiency",
        "\\eta"
    });
    
    formulas.push_back({
        "Efficiency (solve for W_out)",
        "W_{out} = \\eta W_{in}",
        {
            {"W_{out}", {2, -2, 1, 0, 0, 0, 0}, "Work output", false},
            {"\\eta", {0, 0, 0, 0, 0, 0, 0}, "Efficiency", false},
            {"W_{in}", {2, -2, 1, 0, 0, 0, 0}, "Work input", false}
        },
        "Energy",
        "Efficiency",
        "W_{out}"
    });
    
    formulas.push_back({
        "Efficiency (solve for W_in)",
        "W_{in} = \\frac{W_{out}}{\\eta}",
        {
            {"W_{in}", {2, -2, 1, 0, 0, 0, 0}, "Work input", false},
            {"W_{out}", {2, -2, 1, 0, 0, 0, 0}, "Work output", false},
            {"\\eta", {0, 0, 0, 0, 0, 0, 0}, "Efficiency", false}
        },
        "Energy",
        "Efficiency",
        "W_{in}"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_fluids() {
    
    // ========================================================================
    // PRESSURE: P = F / A
    // ========================================================================
    
    formulas.push_back({
        "Pressure (solve for P)",
        "P = \\frac{F}{A}",
        {
            {"P", {-1, -2, 1, 0, 0, 0, 0}, "Pressure", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false}
        },
        "Fluids",
        "Pressure",
        "P"
    });
    
    formulas.push_back({
        "Pressure (solve for F)",
        "F = PA",
        {
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"P", {-1, -2, 1, 0, 0, 0, 0}, "Pressure", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false}
        },
        "Fluids",
        "Pressure",
        "F"
    });
    
    formulas.push_back({
        "Pressure (solve for A)",
        "A = \\frac{F}{P}",
        {
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"P", {-1, -2, 1, 0, 0, 0, 0}, "Pressure", false}
        },
        "Fluids",
        "Pressure",
        "A"
    });
    
    // ========================================================================
    // HYDROSTATIC PRESSURE: P = rho * g * h
    // ========================================================================
    
    formulas.push_back({
        "Hydrostatic Pressure (solve for P)",
        "P = \\rho g h",
        {
            {"P", {-1, -2, 1, 0, 0, 0, 0}, "Pressure", false},
            {"\\rho", {-3, 0, 1, 0, 0, 0, 0}, "Density", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true},
            {"h", {1, 0, 0, 0, 0, 0, 0}, "Height", false}
        },
        "Fluids",
        "Hydrostatic Pressure",
        "P"
    });
    
    formulas.push_back({
        "Hydrostatic Pressure (solve for rho)",
        "\\rho = \\frac{P}{gh}",
        {
            {"\\rho", {-3, 0, 1, 0, 0, 0, 0}, "Density", false},
            {"P", {-1, -2, 1, 0, 0, 0, 0}, "Pressure", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true},
            {"h", {1, 0, 0, 0, 0, 0, 0}, "Height", false}
        },
        "Fluids",
        "Hydrostatic Pressure",
        "\\rho"
    });
    
    formulas.push_back({
        "Hydrostatic Pressure (solve for h)",
        "h = \\frac{P}{\\rho g}",
        {
            {"h", {1, 0, 0, 0, 0, 0, 0}, "Height", false},
            {"P", {-1, -2, 1, 0, 0, 0, 0}, "Pressure", false},
            {"\\rho", {-3, 0, 1, 0, 0, 0, 0}, "Density", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true}
        },
        "Fluids",
        "Hydrostatic Pressure",
        "h"
    });
    
    // ========================================================================
    // BUOYANCY: F_b = rho * V * g
    // ========================================================================
    
    formulas.push_back({
        "Buoyancy (solve for F_b)",
        "F_b = \\rho V g",
        {
            {"F_b", {1, -2, 1, 0, 0, 0, 0}, "Buoyant force", false},
            {"\\rho", {-3, 0, 1, 0, 0, 0, 0}, "Fluid density", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true}
        },
        "Fluids",
        "Buoyancy",
        "F_b"
    });
    
    formulas.push_back({
        "Buoyancy (solve for rho)",
        "\\rho = \\frac{F_b}{Vg}",
        {
            {"\\rho", {-3, 0, 1, 0, 0, 0, 0}, "Fluid density", false},
            {"F_b", {1, -2, 1, 0, 0, 0, 0}, "Buoyant force", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true}
        },
        "Fluids",
        "Buoyancy",
        "\\rho"
    });
    
    formulas.push_back({
        "Buoyancy (solve for V)",
        "V = \\frac{F_b}{\\rho g}",
        {
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false},
            {"F_b", {1, -2, 1, 0, 0, 0, 0}, "Buoyant force", false},
            {"\\rho", {-3, 0, 1, 0, 0, 0, 0}, "Fluid density", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true}
        },
        "Fluids",
        "Buoyancy",
        "V"
    });
    
    // ========================================================================
    // CONTINUITY EQUATION: A_1 * v_1 = A_2 * v_2
    // ========================================================================
    
    formulas.push_back({
        "Continuity Equation (solve for v_2)",
        "v_2 = \\frac{A_1 v_1}{A_2}",
        {
            {"v_2", {1, -1, 0, 0, 0, 0, 0}, "Velocity 2", false},
            {"A_1", {2, 0, 0, 0, 0, 0, 0}, "Area 1", false},
            {"v_1", {1, -1, 0, 0, 0, 0, 0}, "Velocity 1", false},
            {"A_2", {2, 0, 0, 0, 0, 0, 0}, "Area 2", false}
        },
        "Fluids",
        "Continuity Equation",
        "v_2"
    });
    
    formulas.push_back({
        "Continuity Equation (solve for A_2)",
        "A_2 = \\frac{A_1 v_1}{v_2}",
        {
            {"A_2", {2, 0, 0, 0, 0, 0, 0}, "Area 2", false},
            {"A_1", {2, 0, 0, 0, 0, 0, 0}, "Area 1", false},
            {"v_1", {1, -1, 0, 0, 0, 0, 0}, "Velocity 1", false},
            {"v_2", {1, -1, 0, 0, 0, 0, 0}, "Velocity 2", false}
        },
        "Fluids",
        "Continuity Equation",
        "A_2"
    });
    
    // ========================================================================
    // DENSITY: rho = m / V
    // ========================================================================
    
    formulas.push_back({
        "Density (solve for rho)",
        "\\rho = \\frac{m}{V}",
        {
            {"\\rho", {-3, 0, 1, 0, 0, 0, 0}, "Density", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false}
        },
        "Fluids",
        "Density",
        "\\rho"
    });
    
    formulas.push_back({
        "Density (solve for m)",
        "m = \\rho V",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"\\rho", {-3, 0, 1, 0, 0, 0, 0}, "Density", false},
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false}
        },
        "Fluids",
        "Density",
        "m"
    });
    
    formulas.push_back({
        "Density (solve for V)",
        "V = \\frac{m}{\\rho}",
        {
            {"V", {3, 0, 0, 0, 0, 0, 0}, "Volume", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"\\rho", {-3, 0, 1, 0, 0, 0, 0}, "Density", false}
        },
        "Fluids",
        "Density",
        "V"
    });
    
    // ========================================================================
    // FLOW RATE: Q = A * v
    // ========================================================================
    
    formulas.push_back({
        "Flow Rate (solve for Q)",
        "Q = Av",
        {
            {"Q", {3, -1, 0, 0, 0, 0, 0}, "Volume flow rate", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Fluids",
        "Flow Rate",
        "Q"
    });
    
    formulas.push_back({
        "Flow Rate (solve for A)",
        "A = \\frac{Q}{v}",
        {
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false},
            {"Q", {3, -1, 0, 0, 0, 0, 0}, "Volume flow rate", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Fluids",
        "Flow Rate",
        "A"
    });
    
    formulas.push_back({
        "Flow Rate (solve for v)",
        "v = \\frac{Q}{A}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"Q", {3, -1, 0, 0, 0, 0, 0}, "Volume flow rate", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false}
        },
        "Fluids",
        "Flow Rate",
        "v"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_gravity() {
    
    // ========================================================================
    // NEWTON'S LAW OF UNIVERSAL GRAVITATION: F = G * m1 * m2 / r^2
    // ========================================================================
    
    formulas.push_back({
        "Universal Gravitation (solve for F)",
        "F = G\\frac{m_1 m_2}{r^2}",
        {
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Gravitational force", false},
            {"G", {3, -2, -1, 0, 0, 0, 0}, "Gravitational constant", true},
            {"m_1", {0, 0, 1, 0, 0, 0, 0}, "Mass 1", false},
            {"m_2", {0, 0, 1, 0, 0, 0, 0}, "Mass 2", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false}
        },
        "Gravity",
        "Universal Gravitation",
        "F"
    });
    
    formulas.push_back({
        "Universal Gravitation (solve for m_1)",
        "m_1 = \\frac{Fr^2}{Gm_2}",
        {
            {"m_1", {0, 0, 1, 0, 0, 0, 0}, "Mass 1", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Gravitational force", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"G", {3, -2, -1, 0, 0, 0, 0}, "Gravitational constant", true},
            {"m_2", {0, 0, 1, 0, 0, 0, 0}, "Mass 2", false}
        },
        "Gravity",
        "Universal Gravitation",
        "m_1"
    });
    
    formulas.push_back({
        "Universal Gravitation (solve for r)",
        "r = \\sqrt{\\frac{Gm_1 m_2}{F}}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"G", {3, -2, -1, 0, 0, 0, 0}, "Gravitational constant", true},
            {"m_1", {0, 0, 1, 0, 0, 0, 0}, "Mass 1", false},
            {"m_2", {0, 0, 1, 0, 0, 0, 0}, "Mass 2", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Gravitational force", false}
        },
        "Gravity",
        "Universal Gravitation",
        "r"
    });
    
    // ========================================================================
    // GRAVITATIONAL POTENTIAL ENERGY: U = -G * m1 * m2 / r
    // ========================================================================
    
    formulas.push_back({
        "Gravitational Potential Energy (solve for U)",
        "U = -G\\frac{m_1 m_2}{r}",
        {
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false},
            {"G", {3, -2, -1, 0, 0, 0, 0}, "Gravitational constant", true},
            {"m_1", {0, 0, 1, 0, 0, 0, 0}, "Mass 1", false},
            {"m_2", {0, 0, 1, 0, 0, 0, 0}, "Mass 2", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false}
        },
        "Gravity",
        "Gravitational Potential Energy",
        "U"
    });
    
    formulas.push_back({
        "Gravitational Potential Energy (solve for r)",
        "r = -G\\frac{m_1 m_2}{U}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"G", {3, -2, -1, 0, 0, 0, 0}, "Gravitational constant", true},
            {"m_1", {0, 0, 1, 0, 0, 0, 0}, "Mass 1", false},
            {"m_2", {0, 0, 1, 0, 0, 0, 0}, "Mass 2", false},
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false}
        },
        "Gravity",
        "Gravitational Potential Energy",
        "r"
    });
    
    // ========================================================================
    // ORBITAL VELOCITY: v = sqrt(G * M / r)
    // ========================================================================
    
    formulas.push_back({
        "Orbital Velocity (solve for v)",
        "v = \\sqrt{\\frac{GM}{r}}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Orbital velocity", false},
            {"G", {3, -2, -1, 0, 0, 0, 0}, "Gravitational constant", true},
            {"M", {0, 0, 1, 0, 0, 0, 0}, "Central mass", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Orbital radius", false}
        },
        "Gravity",
        "Orbital Velocity",
        "v"
    });
    
    formulas.push_back({
        "Orbital Velocity (solve for M)",
        "M = \\frac{v^2 r}{G}",
        {
            {"M", {0, 0, 1, 0, 0, 0, 0}, "Central mass", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Orbital velocity", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Orbital radius", false},
            {"G", {3, -2, -1, 0, 0, 0, 0}, "Gravitational constant", true}
        },
        "Gravity",
        "Orbital Velocity",
        "M"
    });
    
    formulas.push_back({
        "Orbital Velocity (solve for r)",
        "r = \\frac{GM}{v^2}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Orbital radius", false},
            {"G", {3, -2, -1, 0, 0, 0, 0}, "Gravitational constant", true},
            {"M", {0, 0, 1, 0, 0, 0, 0}, "Central mass", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Orbital velocity", false}
        },
        "Gravity",
        "Orbital Velocity",
        "r"
    });
    
    // ========================================================================
    // ESCAPE VELOCITY: v_esc = sqrt(2 * G * M / r)
    // ========================================================================
    
    formulas.push_back({
        "Escape Velocity (solve for v_esc)",
        "v_{esc} = \\sqrt{\\frac{2GM}{r}}",
        {
            {"v_{esc}", {1, -1, 0, 0, 0, 0, 0}, "Escape velocity", false},
            {"G", {3, -2, -1, 0, 0, 0, 0}, "Gravitational constant", true},
            {"M", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false}
        },
        "Gravity",
        "Escape Velocity",
        "v_{esc}"
    });
    
    formulas.push_back({
        "Escape Velocity (solve for M)",
        "M = \\frac{v_{esc}^2 r}{2G}",
        {
            {"M", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"v_{esc}", {1, -1, 0, 0, 0, 0, 0}, "Escape velocity", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"G", {3, -2, -1, 0, 0, 0, 0}, "Gravitational constant", true}
        },
        "Gravity",
        "Escape Velocity",
        "M"
    });
    
    formulas.push_back({
        "Escape Velocity (solve for r)",
        "r = \\frac{2GM}{v_{esc}^2}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"G", {3, -2, -1, 0, 0, 0, 0}, "Gravitational constant", true},
            {"M", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"v_{esc}", {1, -1, 0, 0, 0, 0, 0}, "Escape velocity", false}
        },
        "Gravity",
        "Escape Velocity",
        "r"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_induction() {
    
    // ========================================================================
    // FARADAY'S LAW: EMF = -N * dPhi/dt (simplified: EMF = N * Delta_Phi / Delta_t)
    // ========================================================================
    
    formulas.push_back({
        "Faraday's Law (solve for EMF)",
        "\\varepsilon = N \\frac{\\Delta \\Phi}{\\Delta t}",
        {
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "Induced EMF", false},
            {"N", {0, 0, 0, 0, 0, 0, 0}, "Number of turns", false},
            {"\\Delta \\Phi", {2, -2, 1, -1, 0, 0, 0}, "Change in magnetic flux", false},
            {"\\Delta t", {0, 1, 0, 0, 0, 0, 0}, "Time interval", false}
        },
        "Induction",
        "Faraday's Law",
        "\\varepsilon"
    });
    
    formulas.push_back({
        "Faraday's Law (solve for N)",
        "N = \\frac{\\varepsilon \\Delta t}{\\Delta \\Phi}",
        {
            {"N", {0, 0, 0, 0, 0, 0, 0}, "Number of turns", false},
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "Induced EMF", false},
            {"\\Delta t", {0, 1, 0, 0, 0, 0, 0}, "Time interval", false},
            {"\\Delta \\Phi", {2, -2, 1, -1, 0, 0, 0}, "Change in magnetic flux", false}
        },
        "Induction",
        "Faraday's Law",
        "N"
    });
    
    formulas.push_back({
        "Faraday's Law (solve for Delta_Phi)",
        "\\Delta \\Phi = \\frac{\\varepsilon \\Delta t}{N}",
        {
            {"\\Delta \\Phi", {2, -2, 1, -1, 0, 0, 0}, "Change in magnetic flux", false},
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "Induced EMF", false},
            {"\\Delta t", {0, 1, 0, 0, 0, 0, 0}, "Time interval", false},
            {"N", {0, 0, 0, 0, 0, 0, 0}, "Number of turns", false}
        },
        "Induction",
        "Faraday's Law",
        "\\Delta \\Phi"
    });
    
    formulas.push_back({
        "Faraday's Law (solve for Delta_t)",
        "\\Delta t = \\frac{N \\Delta \\Phi}{\\varepsilon}",
        {
            {"\\Delta t", {0, 1, 0, 0, 0, 0, 0}, "Time interval", false},
            {"N", {0, 0, 0, 0, 0, 0, 0}, "Number of turns", false},
            {"\\Delta \\Phi", {2, -2, 1, -1, 0, 0, 0}, "Change in magnetic flux", false},
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "Induced EMF", false}
        },
        "Induction",
        "Faraday's Law",
        "\\Delta t"
    });
    
    // ========================================================================
    // MOTIONAL EMF: EMF = B * L * v
    // ========================================================================
    
    formulas.push_back({
        "Motional EMF (solve for EMF)",
        "\\varepsilon = BLv",
        {
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "Induced EMF", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Induction",
        "Motional EMF",
        "\\varepsilon"
    });
    
    formulas.push_back({
        "Motional EMF (solve for B)",
        "B = \\frac{\\varepsilon}{Lv}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "Induced EMF", false},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Induction",
        "Motional EMF",
        "B"
    });
    
    formulas.push_back({
        "Motional EMF (solve for L)",
        "L = \\frac{\\varepsilon}{Bv}",
        {
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false},
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "Induced EMF", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Induction",
        "Motional EMF",
        "L"
    });
    
    formulas.push_back({
        "Motional EMF (solve for v)",
        "v = \\frac{\\varepsilon}{BL}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "Induced EMF", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false}
        },
        "Induction",
        "Motional EMF",
        "v"
    });
    
    // ========================================================================
    // INDUCTANCE EMF: EMF = -L * dI/dt (simplified: EMF = L * Delta_I / Delta_t)
    // ========================================================================
    
    formulas.push_back({
        "Inductance EMF (solve for EMF)",
        "\\varepsilon = L \\frac{\\Delta I}{\\Delta t}",
        {
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "Induced EMF", false},
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"\\Delta I", {0, 0, 0, 1, 0, 0, 0}, "Change in current", false},
            {"\\Delta t", {0, 1, 0, 0, 0, 0, 0}, "Time interval", false}
        },
        "Induction",
        "Inductance EMF",
        "\\varepsilon"
    });
    
    formulas.push_back({
        "Inductance EMF (solve for L)",
        "L = \\frac{\\varepsilon \\Delta t}{\\Delta I}",
        {
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "Induced EMF", false},
            {"\\Delta t", {0, 1, 0, 0, 0, 0, 0}, "Time interval", false},
            {"\\Delta I", {0, 0, 0, 1, 0, 0, 0}, "Change in current", false}
        },
        "Induction",
        "Inductance EMF",
        "L"
    });
    
    formulas.push_back({
        "Inductance EMF (solve for Delta_I)",
        "\\Delta I = \\frac{\\varepsilon \\Delta t}{L}",
        {
            {"\\Delta I", {0, 0, 0, 1, 0, 0, 0}, "Change in current", false},
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "Induced EMF", false},
            {"\\Delta t", {0, 1, 0, 0, 0, 0, 0}, "Time interval", false},
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false}
        },
        "Induction",
        "Inductance EMF",
        "\\Delta I"
    });
    
    formulas.push_back({
        "Inductance EMF (solve for Delta_t)",
        "\\Delta t = \\frac{L \\Delta I}{\\varepsilon}",
        {
            {"\\Delta t", {0, 1, 0, 0, 0, 0, 0}, "Time interval", false},
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"\\Delta I", {0, 0, 0, 1, 0, 0, 0}, "Change in current", false},
            {"\\varepsilon", {2, -3, 1, -1, 0, 0, 0}, "Induced EMF", false}
        },
        "Induction",
        "Inductance EMF",
        "\\Delta t"
    });
    
    // ========================================================================
    // INDUCTOR ENERGY: U = (1/2) * L * I^2
    // ========================================================================
    
    formulas.push_back({
        "Inductor Energy (solve for U)",
        "U = \\frac{1}{2} L I^2",
        {
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Induction",
        "Inductor Energy",
        "U"
    });
    
    formulas.push_back({
        "Inductor Energy (solve for L)",
        "L = \\frac{2U}{I^2}",
        {
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Induction",
        "Inductor Energy",
        "L"
    });
    
    formulas.push_back({
        "Inductor Energy (solve for I)",
        "I = \\sqrt{\\frac{2U}{L}}",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false}
        },
        "Induction",
        "Inductor Energy",
        "I"
    });
    
    // ========================================================================
    // LR TIME CONSTANT: tau = L / R
    // ========================================================================
    
    formulas.push_back({
        "LR Time Constant (solve for tau)",
        "\\tau = \\frac{L}{R}",
        {
            {"\\tau", {0, 1, 0, 0, 0, 0, 0}, "Time constant", false},
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false}
        },
        "Induction",
        "LR Time Constant",
        "\\tau"
    });
    
    formulas.push_back({
        "LR Time Constant (solve for L)",
        "L = \\tau R",
        {
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"\\tau", {0, 1, 0, 0, 0, 0, 0}, "Time constant", false},
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false}
        },
        "Induction",
        "LR Time Constant",
        "L"
    });
    
    formulas.push_back({
        "LR Time Constant (solve for R)",
        "R = \\frac{L}{\\tau}",
        {
            {"R", {2, -3, 1, -2, 0, 0, 0}, "Resistance", false},
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"\\tau", {0, 1, 0, 0, 0, 0, 0}, "Time constant", false}
        },
        "Induction",
        "LR Time Constant",
        "R"
    });
    
    // ========================================================================
    // SOLENOID INDUCTANCE: L = mu_0 * n^2 * A * l
    // ========================================================================
    
    formulas.push_back({
        "Solenoid Inductance (solve for L)",
        "L = \\mu_0 n^2 A l",
        {
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"n", {-1, 0, 0, 0, 0, 0, 0}, "Turns per unit length", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false},
            {"l", {1, 0, 0, 0, 0, 0, 0}, "Length", false}
        },
        "Induction",
        "Solenoid Inductance",
        "L"
    });
    
    formulas.push_back({
        "Solenoid Inductance (solve for n)",
        "n = \\sqrt{\\frac{L}{\\mu_0 A l}}",
        {
            {"n", {-1, 0, 0, 0, 0, 0, 0}, "Turns per unit length", false},
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false},
            {"l", {1, 0, 0, 0, 0, 0, 0}, "Length", false}
        },
        "Induction",
        "Solenoid Inductance",
        "n"
    });
    
    formulas.push_back({
        "Solenoid Inductance (solve for A)",
        "A = \\frac{L}{\\mu_0 n^2 l}",
        {
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false},
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"n", {-1, 0, 0, 0, 0, 0, 0}, "Turns per unit length", false},
            {"l", {1, 0, 0, 0, 0, 0, 0}, "Length", false}
        },
        "Induction",
        "Solenoid Inductance",
        "A"
    });
    
    formulas.push_back({
        "Solenoid Inductance (solve for l)",
        "l = \\frac{L}{\\mu_0 n^2 A}",
        {
            {"l", {1, 0, 0, 0, 0, 0, 0}, "Length", false},
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"n", {-1, 0, 0, 0, 0, 0, 0}, "Turns per unit length", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Cross-sectional area", false}
        },
        "Induction",
        "Solenoid Inductance",
        "l"
    });
    
    // ========================================================================
    // LC CIRCUIT FREQUENCY: omega = 1 / sqrt(L * C)
    // ========================================================================
    
    formulas.push_back({
        "LC Circuit Angular Frequency (solve for omega)",
        "\\omega = \\frac{1}{\\sqrt{LC}}",
        {
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular frequency", false},
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false}
        },
        "Induction",
        "LC Circuit Angular Frequency",
        "\\omega"
    });
    
    formulas.push_back({
        "LC Circuit Angular Frequency (solve for L)",
        "L = \\frac{1}{\\omega^2 C}",
        {
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular frequency", false},
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false}
        },
        "Induction",
        "LC Circuit Angular Frequency",
        "L"
    });
    
    formulas.push_back({
        "LC Circuit Angular Frequency (solve for C)",
        "C = \\frac{1}{\\omega^2 L}",
        {
            {"C", {-2, 4, -1, 2, 0, 0, 0}, "Capacitance", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular frequency", false},
            {"L", {2, -2, 1, -2, 0, 0, 0}, "Inductance", false}
        },
        "Induction",
        "LC Circuit Angular Frequency",
        "C"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_kinematics() {
    
    // ========================================================================
    // VELOCITY WITH ACCELERATION: v = v_0 + a * t
    // ========================================================================
    
    formulas.push_back({
        "Velocity with Acceleration (solve for v)",
        "v = v_0 + at",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Final velocity", false},
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Kinematics",
        "Velocity with Acceleration",
        "v"
    });
    
    formulas.push_back({
        "Velocity with Acceleration (solve for v_0)",
        "v_0 = v - at",
        {
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Final velocity", false},
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Kinematics",
        "Velocity with Acceleration",
        "v_0"
    });
    
    formulas.push_back({
        "Velocity with Acceleration (solve for a)",
        "a = \\frac{v - v_0}{t}",
        {
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Final velocity", false},
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Kinematics",
        "Velocity with Acceleration",
        "a"
    });
    
    formulas.push_back({
        "Velocity with Acceleration (solve for t)",
        "t = \\frac{v - v_0}{a}",
        {
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Final velocity", false},
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false}
        },
        "Kinematics",
        "Velocity with Acceleration",
        "t"
    });
    
    // ========================================================================
    // POSITION WITH ACCELERATION: x = x_0 + v_0*t + (1/2)*a*t^2
    // ========================================================================
    
    formulas.push_back({
        "Position with Acceleration (solve for x)",
        "x = x_0 + v_0 t + \\frac{1}{2}at^2",
        {
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Final position", false},
            {"x_0", {1, 0, 0, 0, 0, 0, 0}, "Initial position", false},
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false},
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false}
        },
        "Kinematics",
        "Position with Acceleration",
        "x"
    });
    
    formulas.push_back({
        "Position with Acceleration (solve for x_0)",
        "x_0 = x - v_0 t - \\frac{1}{2}at^2",
        {
            {"x_0", {1, 0, 0, 0, 0, 0, 0}, "Initial position", false},
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Final position", false},
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false},
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false}
        },
        "Kinematics",
        "Position with Acceleration",
        "x_0"
    });
    
    formulas.push_back({
        "Position with Acceleration (solve for a)",
        "a = \\frac{2(x - x_0 - v_0 t)}{t^2}",
        {
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false},
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Final position", false},
            {"x_0", {1, 0, 0, 0, 0, 0, 0}, "Initial position", false},
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Kinematics",
        "Position with Acceleration",
        "a"
    });
    
    // ========================================================================
    // VELOCITY-POSITION RELATION: v^2 = v_0^2 + 2*a*(x - x_0)
    // ========================================================================
    
    formulas.push_back({
        "Velocity-Position Relation (solve for v)",
        "v^2 = v_0^2 + 2a(x - x_0)",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Final velocity", false},
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false},
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Final position", false},
            {"x_0", {1, 0, 0, 0, 0, 0, 0}, "Initial position", false}
        },
        "Kinematics",
        "Velocity-Position Relation",
        "v"
    });
    
    formulas.push_back({
        "Velocity-Position Relation (solve for v_0)",
        "v_0 = \\sqrt{v^2 - 2a(x - x_0)}",
        {
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Final velocity", false},
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false},
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Final position", false},
            {"x_0", {1, 0, 0, 0, 0, 0, 0}, "Initial position", false}
        },
        "Kinematics",
        "Velocity-Position Relation",
        "v_0"
    });
    
    formulas.push_back({
        "Velocity-Position Relation (solve for a)",
        "a = \\frac{v^2 - v_0^2}{2(x - x_0)}",
        {
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Final velocity", false},
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Final position", false},
            {"x_0", {1, 0, 0, 0, 0, 0, 0}, "Initial position", false}
        },
        "Kinematics",
        "Velocity-Position Relation",
        "a"
    });
    
    formulas.push_back({
        "Velocity-Position Relation (solve for x)",
        "x = x_0 + \\frac{v^2 - v_0^2}{2a}",
        {
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Final position", false},
            {"x_0", {1, 0, 0, 0, 0, 0, 0}, "Initial position", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Final velocity", false},
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"a", {1, -2, 0, 0, 0, 0, 0}, "Acceleration", false}
        },
        "Kinematics",
        "Velocity-Position Relation",
        "x"
    });
    
    // ========================================================================
    // AVERAGE VELOCITY: v_avg = (x - x_0) / t
    // ========================================================================
    
    formulas.push_back({
        "Average Velocity (solve for v_avg)",
        "v_{avg} = \\frac{x - x_0}{t}",
        {
            {"v_{avg}", {1, -1, 0, 0, 0, 0, 0}, "Average velocity", false},
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Final position", false},
            {"x_0", {1, 0, 0, 0, 0, 0, 0}, "Initial position", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Kinematics",
        "Average Velocity",
        "v_{avg}"
    });
    
    formulas.push_back({
        "Average Velocity (solve for x)",
        "x = x_0 + v_{avg} t",
        {
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Final position", false},
            {"x_0", {1, 0, 0, 0, 0, 0, 0}, "Initial position", false},
            {"v_{avg}", {1, -1, 0, 0, 0, 0, 0}, "Average velocity", false},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Kinematics",
        "Average Velocity",
        "x"
    });
    
    formulas.push_back({
        "Average Velocity (solve for t)",
        "t = \\frac{x - x_0}{v_{avg}}",
        {
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false},
            {"x", {1, 0, 0, 0, 0, 0, 0}, "Final position", false},
            {"x_0", {1, 0, 0, 0, 0, 0, 0}, "Initial position", false},
            {"v_{avg}", {1, -1, 0, 0, 0, 0, 0}, "Average velocity", false}
        },
        "Kinematics",
        "Average Velocity",
        "t"
    });
    
    // ========================================================================
    // AVERAGE VELOCITY FROM INITIAL AND FINAL: v_avg = (v_0 + v) / 2
    // ========================================================================
    
    formulas.push_back({
        "Average Velocity from Endpoints (solve for v_avg)",
        "v_{avg} = \\frac{v_0 + v}{2}",
        {
            {"v_{avg}", {1, -1, 0, 0, 0, 0, 0}, "Average velocity", false},
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Final velocity", false}
        },
        "Kinematics",
        "Average Velocity from Endpoints",
        "v_{avg}"
    });
    
    formulas.push_back({
        "Average Velocity from Endpoints (solve for v_0)",
        "v_0 = 2v_{avg} - v",
        {
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false},
            {"v_{avg}", {1, -1, 0, 0, 0, 0, 0}, "Average velocity", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Final velocity", false}
        },
        "Kinematics",
        "Average Velocity from Endpoints",
        "v_0"
    });
    
    formulas.push_back({
        "Average Velocity from Endpoints (solve for v)",
        "v = 2v_{avg} - v_0",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Final velocity", false},
            {"v_{avg}", {1, -1, 0, 0, 0, 0, 0}, "Average velocity", false},
            {"v_0", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity", false}
        },
        "Kinematics",
        "Average Velocity from Endpoints",
        "v"
    });
    
    // ========================================================================
    // FREE FALL: v = g * t (starting from rest, downward positive)
    // ========================================================================
    
    formulas.push_back({
        "Free Fall Velocity (solve for v)",
        "v = gt",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Kinematics",
        "Free Fall Velocity",
        "v"
    });
    
    formulas.push_back({
        "Free Fall Velocity (solve for t)",
        "t = \\frac{v}{g}",
        {
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true}
        },
        "Kinematics",
        "Free Fall Velocity",
        "t"
    });
    
    // ========================================================================
    // FREE FALL DISTANCE: y = (1/2) * g * t^2
    // ========================================================================
    
    formulas.push_back({
        "Free Fall Distance (solve for y)",
        "y = \\frac{1}{2}gt^2",
        {
            {"y", {1, 0, 0, 0, 0, 0, 0}, "Distance fallen", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true},
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false}
        },
        "Kinematics",
        "Free Fall Distance",
        "y"
    });
    
    formulas.push_back({
        "Free Fall Distance (solve for t)",
        "t = \\sqrt{\\frac{2y}{g}}",
        {
            {"t", {0, 1, 0, 0, 0, 0, 0}, "Time", false},
            {"y", {1, 0, 0, 0, 0, 0, 0}, "Distance fallen", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true}
        },
        "Kinematics",
        "Free Fall Distance",
        "t"
    });
    
    // ========================================================================
    // FREE FALL VELOCITY-DISTANCE: v^2 = 2 * g * y
    // ========================================================================
    
    formulas.push_back({
        "Free Fall Velocity-Distance (solve for v)",
        "v^2 = 2gy",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true},
            {"y", {1, 0, 0, 0, 0, 0, 0}, "Distance fallen", false}
        },
        "Kinematics",
        "Free Fall Velocity-Distance",
        "v"
    });
    
    formulas.push_back({
        "Free Fall Velocity-Distance (solve for y)",
        "y = \\frac{v^2}{2g}",
        {
            {"y", {1, 0, 0, 0, 0, 0, 0}, "Distance fallen", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true}
        },
        "Kinematics",
        "Free Fall Velocity-Distance",
        "y"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_magnetism() {
    
    // ========================================================================
    // MAGNETIC FORCE ON MOVING CHARGE: F = q * v * B (perpendicular)
    // ========================================================================
    
    formulas.push_back({
        "Magnetic Force on Charge (solve for F)",
        "F = qvB",
        {
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Magnetic Force on Charge",
        "F"
    });
    
    formulas.push_back({
        "Magnetic Force on Charge (solve for q)",
        "q = \\frac{F}{vB}",
        {
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Magnetic Force on Charge",
        "q"
    });
    
    formulas.push_back({
        "Magnetic Force on Charge (solve for v)",
        "v = \\frac{F}{qB}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Magnetic Force on Charge",
        "v"
    });
    
    formulas.push_back({
        "Magnetic Force on Charge (solve for B)",
        "B = \\frac{F}{qv}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Magnetism",
        "Magnetic Force on Charge",
        "B"
    });
    
    // ========================================================================
    // MAGNETIC FORCE ON CURRENT: F = B * I * L
    // ========================================================================
    
    formulas.push_back({
        "Magnetic Force on Current (solve for F)",
        "F = BIL",
        {
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false}
        },
        "Magnetism",
        "Magnetic Force on Current",
        "F"
    });
    
    formulas.push_back({
        "Magnetic Force on Current (solve for B)",
        "B = \\frac{F}{IL}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false}
        },
        "Magnetism",
        "Magnetic Force on Current",
        "B"
    });
    
    formulas.push_back({
        "Magnetic Force on Current (solve for I)",
        "I = \\frac{F}{BL}",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false}
        },
        "Magnetism",
        "Magnetic Force on Current",
        "I"
    });
    
    formulas.push_back({
        "Magnetic Force on Current (solve for L)",
        "L = \\frac{F}{BI}",
        {
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Magnetism",
        "Magnetic Force on Current",
        "L"
    });
    
    // ========================================================================
    // MAGNETIC FIELD OF STRAIGHT WIRE: B = (mu_0 * I) / (2 * pi * r)
    // ========================================================================
    
    formulas.push_back({
        "Magnetic Field of Wire (solve for B)",
        "B = \\frac{\\mu_0 I}{2\\pi r}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false}
        },
        "Magnetism",
        "Magnetic Field of Wire",
        "B"
    });
    
    formulas.push_back({
        "Magnetic Field of Wire (solve for I)",
        "I = \\frac{2\\pi r B}{\\mu_0}",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true}
        },
        "Magnetism",
        "Magnetic Field of Wire",
        "I"
    });
    
    formulas.push_back({
        "Magnetic Field of Wire (solve for r)",
        "r = \\frac{\\mu_0 I}{2\\pi B}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Magnetic Field of Wire",
        "r"
    });
    
    // ========================================================================
    // MAGNETIC FIELD OF SOLENOID: B = mu_0 * n * I
    // ========================================================================
    
    formulas.push_back({
        "Magnetic Field of Solenoid (solve for B)",
        "B = \\mu_0 n I",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"n", {-1, 0, 0, 0, 0, 0, 0}, "Turns per unit length", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Magnetism",
        "Magnetic Field of Solenoid",
        "B"
    });
    
    formulas.push_back({
        "Magnetic Field of Solenoid (solve for n)",
        "n = \\frac{B}{\\mu_0 I}",
        {
            {"n", {-1, 0, 0, 0, 0, 0, 0}, "Turns per unit length", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Magnetism",
        "Magnetic Field of Solenoid",
        "n"
    });
    
    formulas.push_back({
        "Magnetic Field of Solenoid (solve for I)",
        "I = \\frac{B}{\\mu_0 n}",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"n", {-1, 0, 0, 0, 0, 0, 0}, "Turns per unit length", false}
        },
        "Magnetism",
        "Magnetic Field of Solenoid",
        "I"
    });
    
    // ========================================================================
    // CYCLOTRON RADIUS: r = (m * v) / (q * B)
    // ========================================================================
    
    formulas.push_back({
        "Cyclotron Radius (solve for r)",
        "r = \\frac{mv}{qB}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Cyclotron Radius",
        "r"
    });
    
    formulas.push_back({
        "Cyclotron Radius (solve for m)",
        "m = \\frac{rqB}{v}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Magnetism",
        "Cyclotron Radius",
        "m"
    });
    
    formulas.push_back({
        "Cyclotron Radius (solve for v)",
        "v = \\frac{rqB}{m}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false}
        },
        "Magnetism",
        "Cyclotron Radius",
        "v"
    });
    
    formulas.push_back({
        "Cyclotron Radius (solve for q)",
        "q = \\frac{mv}{rB}",
        {
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Cyclotron Radius",
        "q"
    });
    
    formulas.push_back({
        "Cyclotron Radius (solve for B)",
        "B = \\frac{mv}{qr}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false}
        },
        "Magnetism",
        "Cyclotron Radius",
        "B"
    });
    
    // ========================================================================
    // MAGNETIC FLUX: Phi = B * A * cos(theta)
    // For perpendicular: Phi = B * A
    // ========================================================================
    
    formulas.push_back({
        "Magnetic Flux (solve for Phi)",
        "\\Phi = BA",
        {
            {"\\Phi", {2, -2, 1, -1, 0, 0, 0}, "Magnetic flux", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false}
        },
        "Magnetism",
        "Magnetic Flux",
        "\\Phi"
    });
    
    formulas.push_back({
        "Magnetic Flux (solve for B)",
        "B = \\frac{\\Phi}{A}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\Phi", {2, -2, 1, -1, 0, 0, 0}, "Magnetic flux", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false}
        },
        "Magnetism",
        "Magnetic Flux",
        "B"
    });
    
    formulas.push_back({
        "Magnetic Flux (solve for A)",
        "A = \\frac{\\Phi}{B}",
        {
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area", false},
            {"\\Phi", {2, -2, 1, -1, 0, 0, 0}, "Magnetic flux", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Magnetic Flux",
        "A"
    });
    
    // ========================================================================
    // CYCLOTRON FREQUENCY: f = (q * B) / (2 * pi * m)
    // ========================================================================
    
    formulas.push_back({
        "Cyclotron Frequency (solve for f)",
        "f = \\frac{qB}{2\\pi m}",
        {
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false}
        },
        "Magnetism",
        "Cyclotron Frequency",
        "f"
    });
    
    formulas.push_back({
        "Cyclotron Frequency (solve for q)",
        "q = \\frac{2\\pi m f}{B}",
        {
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Cyclotron Frequency",
        "q"
    });
    
    formulas.push_back({
        "Cyclotron Frequency (solve for B)",
        "B = \\frac{2\\pi m f}{q}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false}
        },
        "Magnetism",
        "Cyclotron Frequency",
        "B"
    });
    
    formulas.push_back({
        "Cyclotron Frequency (solve for m)",
        "m = \\frac{qB}{2\\pi f}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false}
        },
        "Magnetism",
        "Cyclotron Frequency",
        "m"
    });
    // ========================================================================
    // MAGNETIC ENERGY DENSITY: u = B^2 / (2 * mu_0)
    // ========================================================================
    
    formulas.push_back({
        "Magnetic Energy Density (solve for u)",
        "u = \\frac{B^2}{2\\mu_0}",
        {
            {"u", {-1, -2, 1, 0, 0, 0, 0}, "Energy density", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true}
        },
        "Magnetism",
        "Magnetic Energy Density",
        "u"
    });
    
    formulas.push_back({
        "Magnetic Energy Density (solve for B)",
        "B = \\sqrt{2\\mu_0 u}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"u", {-1, -2, 1, 0, 0, 0, 0}, "Energy density", false}
        },
        "Magnetism",
        "Magnetic Energy Density",
        "B"
    });
    
    // ========================================================================
    // HALL EFFECT: V_H = (I * B) / (n * q * t)
    // ========================================================================
    
    formulas.push_back({
        "Hall Voltage (solve for V_H)",
        "V_H = \\frac{IB}{nqt}",
        {
            {"V_H", {2, -3, 1, -1, 0, 0, 0}, "Hall voltage", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"n", {-3, 0, 0, 0, 0, 0, 0}, "Charge carrier density", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge per carrier", false},
            {"t", {1, 0, 0, 0, 0, 0, 0}, "Thickness", false}
        },
        "Magnetism",
        "Hall Voltage",
        "V_H"
    });
    
    formulas.push_back({
        "Hall Voltage (solve for n)",
        "n = \\frac{IB}{qV_H t}",
        {
            {"n", {-3, 0, 0, 0, 0, 0, 0}, "Charge carrier density", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge per carrier", false},
            {"V_H", {2, -3, 1, -1, 0, 0, 0}, "Hall voltage", false},
            {"t", {1, 0, 0, 0, 0, 0, 0}, "Thickness", false}
        },
        "Magnetism",
        "Hall Voltage",
        "n"
    });
    
    formulas.push_back({
        "Hall Voltage (solve for B)",
        "B = \\frac{nqV_H t}{I}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"n", {-3, 0, 0, 0, 0, 0, 0}, "Charge carrier density", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge per carrier", false},
            {"V_H", {2, -3, 1, -1, 0, 0, 0}, "Hall voltage", false},
            {"t", {1, 0, 0, 0, 0, 0, 0}, "Thickness", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Magnetism",
        "Hall Voltage",
        "B"
    });
    
    // ========================================================================
    // AMPERE'S LAW (FOR STRAIGHT WIRE): B * 2*pi*r = mu_0 * I
    // Already covered in "Magnetic Field of Wire", but adding enclosed current form
    // ========================================================================
    
    formulas.push_back({
        "Ampere's Law for Circular Path (solve for B)",
        "B = \\frac{\\mu_0 I_{enc}}{2\\pi r}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"I_{enc}", {0, 0, 0, 1, 0, 0, 0}, "Enclosed current", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance from wire", false}
        },
        "Magnetism",
        "Ampere's Law for Circular Path",
        "B"
    });
    
    formulas.push_back({
        "Ampere's Law for Circular Path (solve for I_enc)",
        "I_{enc} = \\frac{2\\pi r B}{\\mu_0}",
        {
            {"I_{enc}", {0, 0, 0, 1, 0, 0, 0}, "Enclosed current", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance from wire", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true}
        },
        "Magnetism",
        "Ampere's Law for Circular Path",
        "I_{enc}"
    });
    
    // ========================================================================
    // MAGNETIC DIPOLE MOMENT: mu = I * A
    // ========================================================================
    
    formulas.push_back({
        "Magnetic Dipole Moment (solve for mu)",
        "\\mu = IA",
        {
            {"\\mu", {2, 0, 0, 1, 0, 0, 0}, "Magnetic dipole moment", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area of loop", false}
        },
        "Magnetism",
        "Magnetic Dipole Moment",
        "\\mu"
    });
    
    formulas.push_back({
        "Magnetic Dipole Moment (solve for I)",
        "I = \\frac{\\mu}{A}",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"\\mu", {2, 0, 0, 1, 0, 0, 0}, "Magnetic dipole moment", false},
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area of loop", false}
        },
        "Magnetism",
        "Magnetic Dipole Moment",
        "I"
    });
    
    formulas.push_back({
        "Magnetic Dipole Moment (solve for A)",
        "A = \\frac{\\mu}{I}",
        {
            {"A", {2, 0, 0, 0, 0, 0, 0}, "Area of loop", false},
            {"\\mu", {2, 0, 0, 1, 0, 0, 0}, "Magnetic dipole moment", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Magnetism",
        "Magnetic Dipole Moment",
        "A"
    });
    
    // ========================================================================
    // TORQUE ON MAGNETIC DIPOLE: tau = mu * B * sin(theta)
    // For perpendicular: tau = mu * B
    // ========================================================================
    
    formulas.push_back({
        "Torque on Magnetic Dipole (solve for tau)",
        "\\tau = \\mu B",
        {
            {"\\tau", {2, -2, 1, 0, 0, 0, 0}, "Torque", false},
            {"\\mu", {2, 0, 0, 1, 0, 0, 0}, "Magnetic dipole moment", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Torque on Magnetic Dipole",
        "\\tau"
    });
    
    formulas.push_back({
        "Torque on Magnetic Dipole (solve for mu)",
        "\\mu = \\frac{\\tau}{B}",
        {
            {"\\mu", {2, 0, 0, 1, 0, 0, 0}, "Magnetic dipole moment", false},
            {"\\tau", {2, -2, 1, 0, 0, 0, 0}, "Torque", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Torque on Magnetic Dipole",
        "\\mu"
    });
    
    formulas.push_back({
        "Torque on Magnetic Dipole (solve for B)",
        "B = \\frac{\\tau}{\\mu}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\tau", {2, -2, 1, 0, 0, 0, 0}, "Torque", false},
            {"\\mu", {2, 0, 0, 1, 0, 0, 0}, "Magnetic dipole moment", false}
        },
        "Magnetism",
        "Torque on Magnetic Dipole",
        "B"
    });
    
    // ========================================================================
    // POTENTIAL ENERGY OF MAGNETIC DIPOLE: U = -mu * B * cos(theta)
    // For perpendicular: U = -mu * B
    // ========================================================================
    
    formulas.push_back({
        "Magnetic Dipole Potential Energy (solve for U)",
        "U = -\\mu B",
        {
            {"U", {2, -2, 1, 0, 0, 0, 0}, "Potential energy", false},
            {"\\mu", {2, 0, 0, 1, 0, 0, 0}, "Magnetic dipole moment", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Magnetic Dipole Potential Energy",
        "U"
    });
    
    // ========================================================================
    // FORCE BETWEEN PARALLEL CURRENTS: F/L = (mu_0 * I_1 * I_2) / (2 * pi * d)
    // ========================================================================
    
    formulas.push_back({
        "Force Between Parallel Currents (solve for F/L)",
        "\\frac{F}{L} = \\frac{\\mu_0 I_1 I_2}{2\\pi d}",
        {
            {"F/L", {0, -2, 1, 0, 0, 0, 0}, "Force per unit length", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"I_1", {0, 0, 0, 1, 0, 0, 0}, "Current 1", false},
            {"I_2", {0, 0, 0, 1, 0, 0, 0}, "Current 2", false},
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Separation distance", false}
        },
        "Magnetism",
        "Force Between Parallel Currents",
        "F/L"
    });
    
    formulas.push_back({
        "Force Between Parallel Currents (solve for d)",
        "d = \\frac{\\mu_0 I_1 I_2}{2\\pi F/L}",
        {
            {"d", {1, 0, 0, 0, 0, 0, 0}, "Separation distance", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"I_1", {0, 0, 0, 1, 0, 0, 0}, "Current 1", false},
            {"I_2", {0, 0, 0, 1, 0, 0, 0}, "Current 2", false},
            {"F/L", {0, -2, 1, 0, 0, 0, 0}, "Force per unit length", false}
        },
        "Magnetism",
        "Force Between Parallel Currents",
        "d"
    });
    
    // ========================================================================
    // MAGNETIC FIELD AT CENTER OF CIRCULAR LOOP: B = (mu_0 * I) / (2 * r)
    // ========================================================================
    
    formulas.push_back({
        "Magnetic Field at Center of Loop (solve for B)",
        "B = \\frac{\\mu_0 I}{2r}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius of loop", false}
        },
        "Magnetism",
        "Magnetic Field at Center of Loop",
        "B"
    });
    
    formulas.push_back({
        "Magnetic Field at Center of Loop (solve for I)",
        "I = \\frac{2rB}{\\mu_0}",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius of loop", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true}
        },
        "Magnetism",
        "Magnetic Field at Center of Loop",
        "I"
    });
    
    formulas.push_back({
        "Magnetic Field at Center of Loop (solve for r)",
        "r = \\frac{\\mu_0 I}{2B}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius of loop", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Magnetic Field at Center of Loop",
        "r"
    });
    
    // ========================================================================
    // BIOT-SAVART LAW (for small current element): dB = (mu_0 * I * dl * sin(theta)) / (4 * pi * r^2)
    // Conceptual formula
    // ========================================================================
    
    formulas.push_back({
        "Biot-Savart Law (conceptual)",
        "dB = \\frac{\\mu_0 I dl \\sin\\theta}{4\\pi r^2}",
        {
            {"dB", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field element", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"dl", {1, 0, 0, 0, 0, 0, 0}, "Current element length", false},
            {"\\theta", {0, 0, 0, 0, 0, 0, 0}, "Angle", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Distance", false}
        },
        "Magnetism",
        "Biot-Savart Law",
        "dB"
    });
    
    // ========================================================================
    // CYCLOTRON PERIOD: T = (2 * pi * m) / (q * B)
    // ========================================================================
    
    formulas.push_back({
        "Cyclotron Period (solve for T)",
        "T = \\frac{2\\pi m}{qB}",
        {
            {"T", {0, 1, 0, 0, 0, 0, 0}, "Period", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Cyclotron Period",
        "T"
    });
    
    formulas.push_back({
        "Cyclotron Period (solve for m)",
        "m = \\frac{TqB}{2\\pi}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"T", {0, 1, 0, 0, 0, 0, 0}, "Period", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Cyclotron Period",
        "m"
    });
    
    formulas.push_back({
        "Cyclotron Period (solve for B)",
        "B = \\frac{2\\pi m}{qT}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"T", {0, 1, 0, 0, 0, 0, 0}, "Period", false}
        },
        "Magnetism",
        "Cyclotron Period",
        "B"
    });
    
    // ========================================================================
    // MAGNETIC FIELD INSIDE TOROID: B = (mu_0 * N * I) / (2 * pi * r)
    // ========================================================================
    
    formulas.push_back({
        "Magnetic Field in Toroid (solve for B)",
        "B = \\frac{\\mu_0 N I}{2\\pi r}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"N", {0, 0, 0, 0, 0, 0, 0}, "Total number of turns", false},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius to point", false}
        },
        "Magnetism",
        "Magnetic Field in Toroid",
        "B"
    });
    
    formulas.push_back({
        "Magnetic Field in Toroid (solve for N)",
        "N = \\frac{2\\pi r B}{\\mu_0 I}",
        {
            {"N", {0, 0, 0, 0, 0, 0, 0}, "Total number of turns", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius to point", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false}
        },
        "Magnetism",
        "Magnetic Field in Toroid",
        "N"
    });
    
    formulas.push_back({
        "Magnetic Field in Toroid (solve for I)",
        "I = \\frac{2\\pi r B}{\\mu_0 N}",
        {
            {"I", {0, 0, 0, 1, 0, 0, 0}, "Current", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius to point", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"\\mu_0", {1, -2, 1, -2, 0, 0, 0}, "Permeability of free space", true},
            {"N", {0, 0, 0, 0, 0, 0, 0}, "Total number of turns", false}
        },
        "Magnetism",
        "Magnetic Field in Toroid",
        "I"
    });
    
    // ========================================================================
    // VELOCITY SELECTOR: E = v * B (for particles passing through undeflected)
    // ========================================================================
    
    formulas.push_back({
        "Velocity Selector (solve for v)",
        "v = \\frac{E}{B}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Velocity Selector",
        "v"
    });
    
    formulas.push_back({
        "Velocity Selector (solve for E)",
        "E = vB",
        {
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Velocity Selector",
        "E"
    });
    
    formulas.push_back({
        "Velocity Selector (solve for B)",
        "B = \\frac{E}{v}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"E", {1, -3, 1, -1, 0, 0, 0}, "Electric field", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Magnetism",
        "Velocity Selector",
        "B"
    });
    
    // ========================================================================
    // MASS SPECTROMETER: m = (q * B^2 * r^2) / (2 * V)
    // ========================================================================
    
    formulas.push_back({
        "Mass Spectrometer (solve for m)",
        "m = \\frac{qB^2 r^2}{2V}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius of path", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Accelerating voltage", false}
        },
        "Magnetism",
        "Mass Spectrometer",
        "m"
    });
    
    formulas.push_back({
        "Mass Spectrometer (solve for r)",
        "r = \\sqrt{\\frac{2mV}{qB^2}}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius of path", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Accelerating voltage", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false}
        },
        "Magnetism",
        "Mass Spectrometer",
        "r"
    });
    
    formulas.push_back({
        "Mass Spectrometer (solve for B)",
        "B = \\sqrt{\\frac{2mV}{qr^2}}",
        {
            {"B", {0, -2, 1, -1, 0, 0, 0}, "Magnetic field", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"V", {2, -3, 1, -1, 0, 0, 0}, "Accelerating voltage", false},
            {"q", {0, 1, 0, 1, 0, 0, 0}, "Charge", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius of path", false}
        },
        "Magnetism",
        "Mass Spectrometer",
        "B"
    });
}

} // namespace Physics
    
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_modern_physics() {
    
    // ========================================================================
    // PHOTOELECTRIC EFFECT: KE_max = h * f - phi
    // ========================================================================
    
    formulas.push_back({
        "Photoelectric Effect (solve for KE_max)",
        "KE_{max} = hf - \\phi",
        {
            {"KE_{max}", {2, -2, 1, 0, 0, 0, 0}, "Maximum kinetic energy", false},
            {"h", {2, -1, 1, 0, 0, 0, 0}, "Planck's constant", true},
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"\\phi", {2, -2, 1, 0, 0, 0, 0}, "Work function", false}
        },
        "Modern Physics",
        "Photoelectric Effect",
        "KE_{max}"
    });
    
    formulas.push_back({
        "Photoelectric Effect (solve for f)",
        "f = \\frac{KE_{max} + \\phi}{h}",
        {
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"KE_{max}", {2, -2, 1, 0, 0, 0, 0}, "Maximum kinetic energy", false},
            {"\\phi", {2, -2, 1, 0, 0, 0, 0}, "Work function", false},
            {"h", {2, -1, 1, 0, 0, 0, 0}, "Planck's constant", true}
        },
        "Modern Physics",
        "Photoelectric Effect",
        "f"
    });
    
    formulas.push_back({
        "Photoelectric Effect (solve for phi)",
        "\\phi = hf - KE_{max}",
        {
            {"\\phi", {2, -2, 1, 0, 0, 0, 0}, "Work function", false},
            {"h", {2, -1, 1, 0, 0, 0, 0}, "Planck's constant", true},
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"KE_{max}", {2, -2, 1, 0, 0, 0, 0}, "Maximum kinetic energy", false}
        },
        "Modern Physics",
        "Photoelectric Effect",
        "\\phi"
    });
    
    // ========================================================================
    // PHOTON ENERGY: E = h * f
    // ========================================================================
    
    formulas.push_back({
        "Photon Energy (solve for E)",
        "E = hf",
        {
            {"E", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"h", {2, -1, 1, 0, 0, 0, 0}, "Planck's constant", true},
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false}
        },
        "Modern Physics",
        "Photon Energy",
        "E"
    });
    
    formulas.push_back({
        "Photon Energy (solve for f)",
        "f = \\frac{E}{h}",
        {
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"E", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"h", {2, -1, 1, 0, 0, 0, 0}, "Planck's constant", true}
        },
        "Modern Physics",
        "Photon Energy",
        "f"
    });
    
    // ========================================================================
    // DE BROGLIE WAVELENGTH: lambda = h / p
    // ========================================================================
    
    formulas.push_back({
        "de Broglie Wavelength (solve for lambda)",
        "\\lambda = \\frac{h}{p}",
        {
            {"\\lambda", {1, 0, 0, 0, 0, 0, 0}, "Wavelength", false},
            {"h", {2, -1, 1, 0, 0, 0, 0}, "Planck's constant", true},
            {"p", {1, -1, 1, 0, 0, 0, 0}, "Momentum", false}
        },
        "Modern Physics",
        "de Broglie Wavelength",
        "\\lambda"
    });
    
    formulas.push_back({
        "de Broglie Wavelength (solve for p)",
        "p = \\frac{h}{\\lambda}",
        {
            {"p", {1, -1, 1, 0, 0, 0, 0}, "Momentum", false},
            {"h", {2, -1, 1, 0, 0, 0, 0}, "Planck's constant", true},
            {"\\lambda", {1, 0, 0, 0, 0, 0, 0}, "Wavelength", false}
        },
        "Modern Physics",
        "de Broglie Wavelength",
        "p"
    });
    
    // ========================================================================
    // MASS-ENERGY EQUIVALENCE: E = m * c^2
    // ========================================================================
    
    formulas.push_back({
        "Mass-Energy Equivalence (solve for E)",
        "E = mc^2",
        {
            {"E", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"c", {1, -1, 0, 0, 0, 0, 0}, "Speed of light", true}
        },
        "Modern Physics",
        "Mass-Energy Equivalence",
        "E"
    });
    
    formulas.push_back({
        "Mass-Energy Equivalence (solve for m)",
        "m = \\frac{E}{c^2}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"E", {2, -2, 1, 0, 0, 0, 0}, "Energy", false},
            {"c", {1, -1, 0, 0, 0, 0, 0}, "Speed of light", true}
        },
        "Modern Physics",
        "Mass-Energy Equivalence",
        "m"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_momentum() {
    
    // ========================================================================
    // MOMENTUM: p = m * v
    // ========================================================================
    
    formulas.push_back({
        "Momentum (solve for p)",
        "p = mv",
        {
            {"p", {1, -1, 1, 0, 0, 0, 0}, "Momentum", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Momentum",
        "Momentum",
        "p"
    });
    
    formulas.push_back({
        "Momentum (solve for m)",
        "m = \\frac{p}{v}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"p", {1, -1, 1, 0, 0, 0, 0}, "Momentum", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false}
        },
        "Momentum",
        "Momentum",
        "m"
    });
    
    formulas.push_back({
        "Momentum (solve for v)",
        "v = \\frac{p}{m}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Velocity", false},
            {"p", {1, -1, 1, 0, 0, 0, 0}, "Momentum", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false}
        },
        "Momentum",
        "Momentum",
        "v"
    });
    
    // ========================================================================
    // IMPULSE-MOMENTUM THEOREM: J = Delta_p
    // ========================================================================
    
    formulas.push_back({
        "Impulse-Momentum Theorem (solve for J)",
        "J = \\Delta p",
        {
            {"J", {1, -1, 1, 0, 0, 0, 0}, "Impulse", false},
            {"\\Delta p", {1, -1, 1, 0, 0, 0, 0}, "Change in momentum", false}
        },
        "Momentum",
        "Impulse-Momentum Theorem",
        "J"
    });
    
    formulas.push_back({
        "Impulse-Momentum Theorem (solve for Delta_p)",
        "\\Delta p = J",
        {
            {"\\Delta p", {1, -1, 1, 0, 0, 0, 0}, "Change in momentum", false},
            {"J", {1, -1, 1, 0, 0, 0, 0}, "Impulse", false}
        },
        "Momentum",
        "Impulse-Momentum Theorem",
        "\\Delta p"
    });
    
    // ========================================================================
    // CHANGE IN MOMENTUM: Delta_p = m * Delta_v
    // ========================================================================
    
    formulas.push_back({
        "Change in Momentum (solve for Delta_p)",
        "\\Delta p = m\\Delta v",
        {
            {"\\Delta p", {1, -1, 1, 0, 0, 0, 0}, "Change in momentum", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"\\Delta v", {1, -1, 0, 0, 0, 0, 0}, "Change in velocity", false}
        },
        "Momentum",
        "Change in Momentum",
        "\\Delta p"
    });
    
    formulas.push_back({
        "Change in Momentum (solve for m)",
        "m = \\frac{\\Delta p}{\\Delta v}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"\\Delta p", {1, -1, 1, 0, 0, 0, 0}, "Change in momentum", false},
            {"\\Delta v", {1, -1, 0, 0, 0, 0, 0}, "Change in velocity", false}
        },
        "Momentum",
        "Change in Momentum",
        "m"
    });
    
    formulas.push_back({
        "Change in Momentum (solve for Delta_v)",
        "\\Delta v = \\frac{\\Delta p}{m}",
        {
            {"\\Delta v", {1, -1, 0, 0, 0, 0, 0}, "Change in velocity", false},
            {"\\Delta p", {1, -1, 1, 0, 0, 0, 0}, "Change in momentum", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false}
        },
        "Momentum",
        "Change in Momentum",
        "\\Delta v"
    });
    
    // ========================================================================
    // ELASTIC COLLISION (1D): v_1f = ((m_1-m_2)/(m_1+m_2)) * v_1i + ((2*m_2)/(m_1+m_2)) * v_2i
    // Conservation formulas only
    // ========================================================================
    
    formulas.push_back({
        "Conservation of Momentum (solve for total p_f)",
        "p_f = p_i",
        {
            {"p_f", {1, -1, 1, 0, 0, 0, 0}, "Final momentum", false},
            {"p_i", {1, -1, 1, 0, 0, 0, 0}, "Initial momentum", false}
        },
        "Momentum",
        "Conservation of Momentum",
        "p_f"
    });
    
    // ========================================================================
    // INELASTIC COLLISION: m_1*v_1i + m_2*v_2i = (m_1+m_2)*v_f
    // ========================================================================
    
    formulas.push_back({
        "Perfectly Inelastic Collision (solve for v_f)",
        "v_f = \\frac{m_1 v_{1i} + m_2 v_{2i}}{m_1 + m_2}",
        {
            {"v_f", {1, -1, 0, 0, 0, 0, 0}, "Final velocity", false},
            {"m_1", {0, 0, 1, 0, 0, 0, 0}, "Mass 1", false},
            {"v_{1i}", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity 1", false},
            {"m_2", {0, 0, 1, 0, 0, 0, 0}, "Mass 2", false},
            {"v_{2i}", {1, -1, 0, 0, 0, 0, 0}, "Initial velocity 2", false}
        },
        "Momentum",
        "Perfectly Inelastic Collision",
        "v_f"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_optics() {
    
    // ========================================================================
    // SNELL'S LAW: n_1 * sin(theta_1) = n_2 * sin(theta_2)
    // ========================================================================
    
    formulas.push_back({
        "Snell's Law (relationship)",
        "n_1 \\sin\\theta_1 = n_2 \\sin\\theta_2",
        {
            {"n_1", {0, 0, 0, 0, 0, 0, 0}, "Index of refraction 1", false},
            {"\\theta_1", {0, 0, 0, 0, 0, 0, 0}, "Angle 1", false},
            {"n_2", {0, 0, 0, 0, 0, 0, 0}, "Index of refraction 2", false},
            {"\\theta_2", {0, 0, 0, 0, 0, 0, 0}, "Angle 2", false}
        },
        "Optics",
        "Snell's Law",
        "relationship"
    });
    
    // ========================================================================
    // THIN LENS EQUATION: 1/f = 1/d_o + 1/d_i
    // ========================================================================
    
    formulas.push_back({
        "Thin Lens Equation (relationship)",
        "\\frac{1}{f} = \\frac{1}{d_o} + \\frac{1}{d_i}",
        {
            {"f", {1, 0, 0, 0, 0, 0, 0}, "Focal length", false},
            {"d_o", {1, 0, 0, 0, 0, 0, 0}, "Object distance", false},
            {"d_i", {1, 0, 0, 0, 0, 0, 0}, "Image distance", false}
        },
        "Optics",
        "Thin Lens Equation",
        "relationship"
    });
    
    // ========================================================================
    // MAGNIFICATION: m = -d_i / d_o
    // ========================================================================
    
    formulas.push_back({
        "Magnification (solve for m)",
        "m = -\\frac{d_i}{d_o}",
        {
            {"m", {0, 0, 0, 0, 0, 0, 0}, "Magnification", false},
            {"d_i", {1, 0, 0, 0, 0, 0, 0}, "Image distance", false},
            {"d_o", {1, 0, 0, 0, 0, 0, 0}, "Object distance", false}
        },
        "Optics",
        "Magnification",
        "m"
    });
    
    formulas.push_back({
        "Magnification (solve for d_i)",
        "d_i = -m d_o",
        {
            {"d_i", {1, 0, 0, 0, 0, 0, 0}, "Image distance", false},
            {"m", {0, 0, 0, 0, 0, 0, 0}, "Magnification", false},
            {"d_o", {1, 0, 0, 0, 0, 0, 0}, "Object distance", false}
        },
        "Optics",
        "Magnification",
        "d_i"
    });
    
    formulas.push_back({
        "Magnification (solve for d_o)",
        "d_o = -\\frac{d_i}{m}",
        {
            {"d_o", {1, 0, 0, 0, 0, 0, 0}, "Object distance", false},
            {"d_i", {1, 0, 0, 0, 0, 0, 0}, "Image distance", false},
            {"m", {0, 0, 0, 0, 0, 0, 0}, "Magnification", false}
        },
        "Optics",
        "Magnification",
        "d_o"
    });
    
    // ========================================================================
    // MAGNIFICATION HEIGHT: m = h_i / h_o
    // ========================================================================
    
    formulas.push_back({
        "Magnification from Height (solve for m)",
        "m = \\frac{h_i}{h_o}",
        {
            {"m", {0, 0, 0, 0, 0, 0, 0}, "Magnification", false},
            {"h_i", {1, 0, 0, 0, 0, 0, 0}, "Image height", false},
            {"h_o", {1, 0, 0, 0, 0, 0, 0}, "Object height", false}
        },
        "Optics",
        "Magnification from Height",
        "m"
    });
    
    formulas.push_back({
        "Magnification from Height (solve for h_i)",
        "h_i = m h_o",
        {
            {"h_i", {1, 0, 0, 0, 0, 0, 0}, "Image height", false},
            {"m", {0, 0, 0, 0, 0, 0, 0}, "Magnification", false},
            {"h_o", {1, 0, 0, 0, 0, 0, 0}, "Object height", false}
        },
        "Optics",
        "Magnification from Height",
        "h_i"
    });
    
    formulas.push_back({
        "Magnification from Height (solve for h_o)",
        "h_o = \\frac{h_i}{m}",
        {
            {"h_o", {1, 0, 0, 0, 0, 0, 0}, "Object height", false},
            {"h_i", {1, 0, 0, 0, 0, 0, 0}, "Image height", false},
            {"m", {0, 0, 0, 0, 0, 0, 0}, "Magnification", false}
        },
        "Optics",
        "Magnification from Height",
        "h_o"
    });
    
    // ========================================================================
    // INDEX OF REFRACTION: n = c / v
    // ========================================================================
    
    formulas.push_back({
        "Index of Refraction (solve for n)",
        "n = \\frac{c}{v}",
        {
            {"n", {0, 0, 0, 0, 0, 0, 0}, "Index of refraction", false},
            {"c", {1, -1, 0, 0, 0, 0, 0}, "Speed of light in vacuum", true},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Speed of light in medium", false}
        },
        "Optics",
        "Index of Refraction",
        "n"
    });
    
    formulas.push_back({
        "Index of Refraction (solve for v)",
        "v = \\frac{c}{n}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Speed of light in medium", false},
            {"c", {1, -1, 0, 0, 0, 0, 0}, "Speed of light in vacuum", true},
            {"n", {0, 0, 0, 0, 0, 0, 0}, "Index of refraction", false}
        },
        "Optics",
        "Index of Refraction",
        "v"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_oscillations() {
    
    // ========================================================================
    // SIMPLE HARMONIC MOTION ANGULAR FREQUENCY: omega = sqrt(k/m)
    // ========================================================================
    
    formulas.push_back({
        "SHM Angular Frequency (solve for omega)",
        "\\omega = \\sqrt{\\frac{k}{m}}",
        {
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular frequency", false},
            {"k", {0, -2, 1, 0, 0, 0, 0}, "Spring constant", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false}
        },
        "Oscillations",
        "SHM Angular Frequency",
        "\\omega"
    });
    
    formulas.push_back({
        "SHM Angular Frequency (solve for k)",
        "k = m\\omega^2",
        {
            {"k", {0, -2, 1, 0, 0, 0, 0}, "Spring constant", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular frequency", false}
        },
        "Oscillations",
        "SHM Angular Frequency",
        "k"
    });
    
    formulas.push_back({
        "SHM Angular Frequency (solve for m)",
        "m = \\frac{k}{\\omega^2}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"k", {0, -2, 1, 0, 0, 0, 0}, "Spring constant", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular frequency", false}
        },
        "Oscillations",
        "SHM Angular Frequency",
        "m"
    });
    
    // ========================================================================
    // PERIOD OF MASS-SPRING: T = 2*pi*sqrt(m/k)
    // ========================================================================
    
    formulas.push_back({
        "Mass-Spring Period (solve for T)",
        "T = 2\\pi\\sqrt{\\frac{m}{k}}",
        {
            {"T", {0, 1, 0, 0, 0, 0, 0}, "Period", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"k", {0, -2, 1, 0, 0, 0, 0}, "Spring constant", false}
        },
        "Oscillations",
        "Mass-Spring Period",
        "T"
    });
    
    formulas.push_back({
        "Mass-Spring Period (solve for m)",
        "m = \\frac{kT^2}{4\\pi^2}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"k", {0, -2, 1, 0, 0, 0, 0}, "Spring constant", false},
            {"T", {0, 1, 0, 0, 0, 0, 0}, "Period", false}
        },
        "Oscillations",
        "Mass-Spring Period",
        "m"
    });
    
    formulas.push_back({
        "Mass-Spring Period (solve for k)",
        "k = \\frac{4\\pi^2 m}{T^2}",
        {
            {"k", {0, -2, 1, 0, 0, 0, 0}, "Spring constant", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"T", {0, 1, 0, 0, 0, 0, 0}, "Period", false}
        },
        "Oscillations",
        "Mass-Spring Period",
        "k"
    });
    
    // ========================================================================
    // SIMPLE PENDULUM PERIOD: T = 2*pi*sqrt(L/g)
    // ========================================================================
    
    formulas.push_back({
        "Simple Pendulum Period (solve for T)",
        "T = 2\\pi\\sqrt{\\frac{L}{g}}",
        {
            {"T", {0, 1, 0, 0, 0, 0, 0}, "Period", false},
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true}
        },
        "Oscillations",
        "Simple Pendulum Period",
        "T"
    });
    
    formulas.push_back({
        "Simple Pendulum Period (solve for L)",
        "L = \\frac{gT^2}{4\\pi^2}",
        {
            {"L", {1, 0, 0, 0, 0, 0, 0}, "Length", false},
            {"g", {1, -2, 0, 0, 0, 0, 0}, "Gravitational acceleration", true},
            {"T", {0, 1, 0, 0, 0, 0, 0}, "Period", false}
        },
        "Oscillations",
        "Simple Pendulum Period",
        "L"
    });
    
    // ========================================================================
    // FREQUENCY: f = 1/T
    // ========================================================================
    
    formulas.push_back({
        "Frequency (solve for f)",
        "f = \\frac{1}{T}",
        {
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"T", {0, 1, 0, 0, 0, 0, 0}, "Period", false}
        },
        "Oscillations",
        "Frequency",
        "f"
    });
    
    formulas.push_back({
        "Frequency (solve for T)",
        "T = \\frac{1}{f}",
        {
            {"T", {0, 1, 0, 0, 0, 0, 0}, "Period", false},
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false}
        },
        "Oscillations",
        "Frequency",
        "T"
    });
    
    // ========================================================================
    // ANGULAR FREQUENCY: omega = 2*pi*f
    // ========================================================================
    
    formulas.push_back({
        "Angular Frequency (solve for omega)",
        "\\omega = 2\\pi f",
        {
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular frequency", false},
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false}
        },
        "Oscillations",
        "Angular Frequency",
        "\\omega"
    });
    
    formulas.push_back({
        "Angular Frequency (solve for f)",
        "f = \\frac{\\omega}{2\\pi}",
        {
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular frequency", false}
        },
        "Oscillations",
        "Angular Frequency",
        "f"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_rotational_mechanics() {
    
    // ========================================================================
    // TORQUE: tau = r * F
    // ========================================================================
    
    formulas.push_back({
        "Torque (solve for tau)",
        "\\tau = rF",
        {
            {"\\tau", {2, -2, 1, 0, 0, 0, 0}, "Torque", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false}
        },
        "Rotational Mechanics",
        "Torque",
        "\\tau"
    });
    
    formulas.push_back({
        "Torque (solve for r)",
        "r = \\frac{\\tau}{F}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"\\tau", {2, -2, 1, 0, 0, 0, 0}, "Torque", false},
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false}
        },
        "Rotational Mechanics",
        "Torque",
        "r"
    });
    
    formulas.push_back({
        "Torque (solve for F)",
        "F = \\frac{\\tau}{r}",
        {
            {"F", {1, -2, 1, 0, 0, 0, 0}, "Force", false},
            {"\\tau", {2, -2, 1, 0, 0, 0, 0}, "Torque", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false}
        },
        "Rotational Mechanics",
        "Torque",
        "F"
    });
    
    // ========================================================================
    // ROTATIONAL NEWTON'S SECOND: tau = I * alpha
    // ========================================================================
    
    formulas.push_back({
        "Rotational Second Law (solve for tau)",
        "\\tau = I\\alpha",
        {
            {"\\tau", {2, -2, 1, 0, 0, 0, 0}, "Torque", false},
            {"I", {2, 0, 1, 0, 0, 0, 0}, "Moment of inertia", false},
            {"\\alpha", {0, -2, 0, 0, 0, 0, 0}, "Angular acceleration", false}
        },
        "Rotational Mechanics",
        "Rotational Second Law",
        "\\tau"
    });
    
    formulas.push_back({
        "Rotational Second Law (solve for I)",
        "I = \\frac{\\tau}{\\alpha}",
        {
            {"I", {2, 0, 1, 0, 0, 0, 0}, "Moment of inertia", false},
            {"\\tau", {2, -2, 1, 0, 0, 0, 0}, "Torque", false},
            {"\\alpha", {0, -2, 0, 0, 0, 0, 0}, "Angular acceleration", false}
        },
        "Rotational Mechanics",
        "Rotational Second Law",
        "I"
    });
    
    formulas.push_back({
        "Rotational Second Law (solve for alpha)",
        "\\alpha = \\frac{\\tau}{I}",
        {
            {"\\alpha", {0, -2, 0, 0, 0, 0, 0}, "Angular acceleration", false},
            {"\\tau", {2, -2, 1, 0, 0, 0, 0}, "Torque", false},
            {"I", {2, 0, 1, 0, 0, 0, 0}, "Moment of inertia", false}
        },
        "Rotational Mechanics",
        "Rotational Second Law",
        "\\alpha"
    });
    
    // ========================================================================
    // ROTATIONAL KINETIC ENERGY: KE_rot = (1/2) * I * omega^2
    // ========================================================================
    
    formulas.push_back({
        "Rotational Kinetic Energy (solve for KE)",
        "KE = \\frac{1}{2}I\\omega^2",
        {
            {"KE", {2, -2, 1, 0, 0, 0, 0}, "Kinetic energy", false},
            {"I", {2, 0, 1, 0, 0, 0, 0}, "Moment of inertia", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false}
        },
        "Rotational Mechanics",
        "Rotational Kinetic Energy",
        "KE"
    });
    
    formulas.push_back({
        "Rotational Kinetic Energy (solve for I)",
        "I = \\frac{2KE}{\\omega^2}",
        {
            {"I", {2, 0, 1, 0, 0, 0, 0}, "Moment of inertia", false},
            {"KE", {2, -2, 1, 0, 0, 0, 0}, "Kinetic energy", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false}
        },
        "Rotational Mechanics",
        "Rotational Kinetic Energy",
        "I"
    });
    
    formulas.push_back({
        "Rotational Kinetic Energy (solve for omega)",
        "\\omega = \\sqrt{\\frac{2KE}{I}}",
        {
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false},
            {"KE", {2, -2, 1, 0, 0, 0, 0}, "Kinetic energy", false},
            {"I", {2, 0, 1, 0, 0, 0, 0}, "Moment of inertia", false}
        },
        "Rotational Mechanics",
        "Rotational Kinetic Energy",
        "\\omega"
    });
    
    // ========================================================================
    // ANGULAR MOMENTUM: L = I * omega
    // ========================================================================
    
    formulas.push_back({
        "Angular Momentum (solve for L)",
        "L = I\\omega",
        {
            {"L", {2, -1, 1, 0, 0, 0, 0}, "Angular momentum", false},
            {"I", {2, 0, 1, 0, 0, 0, 0}, "Moment of inertia", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false}
        },
        "Rotational Mechanics",
        "Angular Momentum",
        "L"
    });
    
    formulas.push_back({
        "Angular Momentum (solve for I)",
        "I = \\frac{L}{\\omega}",
        {
            {"I", {2, 0, 1, 0, 0, 0, 0}, "Moment of inertia", false},
            {"L", {2, -1, 1, 0, 0, 0, 0}, "Angular momentum", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false}
        },
        "Rotational Mechanics",
        "Angular Momentum",
        "I"
    });
    
    formulas.push_back({
        "Angular Momentum (solve for omega)",
        "\\omega = \\frac{L}{I}",
        {
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false},
            {"L", {2, -1, 1, 0, 0, 0, 0}, "Angular momentum", false},
            {"I", {2, 0, 1, 0, 0, 0, 0}, "Moment of inertia", false}
        },
        "Rotational Mechanics",
        "Angular Momentum",
        "\\omega"
    });
    
    // ========================================================================
    // LINEAR-ANGULAR VELOCITY: v = r * omega
    // ========================================================================
    
    formulas.push_back({
        "Linear-Angular Velocity (solve for v)",
        "v = r\\omega",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Linear velocity", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false}
        },
        "Rotational Mechanics",
        "Linear-Angular Velocity",
        "v"
    });
    
    formulas.push_back({
        "Linear-Angular Velocity (solve for r)",
        "r = \\frac{v}{\\omega}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Linear velocity", false},
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false}
        },
        "Rotational Mechanics",
        "Linear-Angular Velocity",
        "r"
    });
    
    formulas.push_back({
        "Linear-Angular Velocity (solve for omega)",
        "\\omega = \\frac{v}{r}",
        {
            {"\\omega", {0, -1, 0, 0, 0, 0, 0}, "Angular velocity", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Linear velocity", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false}
        },
        "Rotational Mechanics",
        "Linear-Angular Velocity",
        "\\omega"
    });
    
    // ========================================================================
    // MOMENT OF INERTIA POINT MASS: I = m * r^2
    // ========================================================================
    
    formulas.push_back({
        "Moment of Inertia Point Mass (solve for I)",
        "I = mr^2",
        {
            {"I", {2, 0, 1, 0, 0, 0, 0}, "Moment of inertia", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false}
        },
        "Rotational Mechanics",
        "Moment of Inertia Point Mass",
        "I"
    });
    
    formulas.push_back({
        "Moment of Inertia Point Mass (solve for m)",
        "m = \\frac{I}{r^2}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"I", {2, 0, 1, 0, 0, 0, 0}, "Moment of inertia", false},
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false}
        },
        "Rotational Mechanics",
        "Moment of Inertia Point Mass",
        "m"
    });
    
    formulas.push_back({
        "Moment of Inertia Point Mass (solve for r)",
        "r = \\sqrt{\\frac{I}{m}}",
        {
            {"r", {1, 0, 0, 0, 0, 0, 0}, "Radius", false},
            {"I", {2, 0, 1, 0, 0, 0, 0}, "Moment of inertia", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false}
        },
        "Rotational Mechanics",
        "Moment of Inertia Point Mass",
        "r"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_thermodynamics() {
    
    // ========================================================================
    // HEAT TRANSFER: Q = m * c * Delta_T
    // ========================================================================
    
    formulas.push_back({
        "Heat Transfer (solve for Q)",
        "Q = mc\\Delta T",
        {
            {"Q", {2, -2, 1, 0, 0, 0, 0}, "Heat", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"c", {2, -2, 0, 0, -1, 0, 0}, "Specific heat capacity", false},
            {"\\Delta T", {0, 0, 0, 0, 1, 0, 0}, "Temperature change", false}
        },
        "Thermodynamics",
        "Heat Transfer",
        "Q"
    });
    
    formulas.push_back({
        "Heat Transfer (solve for m)",
        "m = \\frac{Q}{c\\Delta T}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"Q", {2, -2, 1, 0, 0, 0, 0}, "Heat", false},
            {"c", {2, -2, 0, 0, -1, 0, 0}, "Specific heat capacity", false},
            {"\\Delta T", {0, 0, 0, 0, 1, 0, 0}, "Temperature change", false}
        },
        "Thermodynamics",
        "Heat Transfer",
        "m"
    });
    
    formulas.push_back({
        "Heat Transfer (solve for c)",
        "c = \\frac{Q}{m\\Delta T}",
        {
            {"c", {2, -2, 0, 0, -1, 0, 0}, "Specific heat capacity", false},
            {"Q", {2, -2, 1, 0, 0, 0, 0}, "Heat", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"\\Delta T", {0, 0, 0, 0, 1, 0, 0}, "Temperature change", false}
        },
        "Thermodynamics",
        "Heat Transfer",
        "c"
    });
    
    formulas.push_back({
        "Heat Transfer (solve for Delta_T)",
        "\\Delta T = \\frac{Q}{mc}",
        {
            {"\\Delta T", {0, 0, 0, 0, 1, 0, 0}, "Temperature change", false},
            {"Q", {2, -2, 1, 0, 0, 0, 0}, "Heat", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"c", {2, -2, 0, 0, -1, 0, 0}, "Specific heat capacity", false}
        },
        "Thermodynamics",
        "Heat Transfer",
        "\\Delta T"
    });
    
    // ========================================================================
    // LATENT HEAT: Q = m * L
    // ========================================================================
    
    formulas.push_back({
        "Latent Heat (solve for Q)",
        "Q = mL",
        {
            {"Q", {2, -2, 1, 0, 0, 0, 0}, "Heat", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"L", {2, -2, 0, 0, 0, 0, 0}, "Latent heat", false}
        },
        "Thermodynamics",
        "Latent Heat",
        "Q"
    });
    
    formulas.push_back({
        "Latent Heat (solve for m)",
        "m = \\frac{Q}{L}",
        {
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false},
            {"Q", {2, -2, 1, 0, 0, 0, 0}, "Heat", false},
            {"L", {2, -2, 0, 0, 0, 0, 0}, "Latent heat", false}
        },
        "Thermodynamics",
        "Latent Heat",
        "m"
    });
    
    formulas.push_back({
        "Latent Heat (solve for L)",
        "L = \\frac{Q}{m}",
        {
            {"L", {2, -2, 0, 0, 0, 0, 0}, "Latent heat", false},
            {"Q", {2, -2, 1, 0, 0, 0, 0}, "Heat", false},
            {"m", {0, 0, 1, 0, 0, 0, 0}, "Mass", false}
        },
        "Thermodynamics",
        "Latent Heat",
        "L"
    });
    
    // ========================================================================
    // THERMAL EXPANSION (LINEAR): Delta_L = alpha * L_0 * Delta_T
    // ========================================================================
    
    formulas.push_back({
        "Linear Thermal Expansion (solve for Delta_L)",
        "\\Delta L = \\alpha L_0 \\Delta T",
        {
            {"\\Delta L", {1, 0, 0, 0, 0, 0, 0}, "Change in length", false},
            {"\\alpha", {0, 0, 0, 0, -1, 0, 0}, "Coefficient of linear expansion", false},
            {"L_0", {1, 0, 0, 0, 0, 0, 0}, "Initial length", false},
            {"\\Delta T", {0, 0, 0, 0, 1, 0, 0}, "Temperature change", false}
        },
        "Thermodynamics",
        "Linear Thermal Expansion",
        "\\Delta L"
    });
    
    formulas.push_back({
        "Linear Thermal Expansion (solve for alpha)",
        "\\alpha = \\frac{\\Delta L}{L_0 \\Delta T}",
        {
            {"\\alpha", {0, 0, 0, 0, -1, 0, 0}, "Coefficient of linear expansion", false},
            {"\\Delta L", {1, 0, 0, 0, 0, 0, 0}, "Change in length", false},
            {"L_0", {1, 0, 0, 0, 0, 0, 0}, "Initial length", false},
            {"\\Delta T", {0, 0, 0, 0, 1, 0, 0}, "Temperature change", false}
        },
        "Thermodynamics",
        "Linear Thermal Expansion",
        "\\alpha"
    });
    
    // ========================================================================
    // FIRST LAW OF THERMODYNAMICS: Delta_U = Q - W
    // ========================================================================
    
    formulas.push_back({
        "First Law of Thermodynamics (solve for Delta_U)",
        "\\Delta U = Q - W",
        {
            {"\\Delta U", {2, -2, 1, 0, 0, 0, 0}, "Change in internal energy", false},
            {"Q", {2, -2, 1, 0, 0, 0, 0}, "Heat added", false},
            {"W", {2, -2, 1, 0, 0, 0, 0}, "Work done by system", false}
        },
        "Thermodynamics",
        "First Law of Thermodynamics",
        "\\Delta U"
    });
    
    formulas.push_back({
        "First Law of Thermodynamics (solve for Q)",
        "Q = \\Delta U + W",
        {
            {"Q", {2, -2, 1, 0, 0, 0, 0}, "Heat added", false},
            {"\\Delta U", {2, -2, 1, 0, 0, 0, 0}, "Change in internal energy", false},
            {"W", {2, -2, 1, 0, 0, 0, 0}, "Work done by system", false}
        },
        "Thermodynamics",
        "First Law of Thermodynamics",
        "Q"
    });
    
    formulas.push_back({
        "First Law of Thermodynamics (solve for W)",
        "W = Q - \\Delta U",
        {
            {"W", {2, -2, 1, 0, 0, 0, 0}, "Work done by system", false},
            {"Q", {2, -2, 1, 0, 0, 0, 0}, "Heat added", false},
            {"\\Delta U", {2, -2, 1, 0, 0, 0, 0}, "Change in internal energy", false}
        },
        "Thermodynamics",
        "First Law of Thermodynamics",
        "W"
    });
    
    // ========================================================================
    // CARNOT EFFICIENCY: eta = 1 - T_c / T_h
    // ========================================================================
    
    formulas.push_back({
        "Carnot Efficiency (solve for eta)",
        "\\eta = 1 - \\frac{T_c}{T_h}",
        {
            {"\\eta", {0, 0, 0, 0, 0, 0, 0}, "Efficiency", false},
            {"T_c", {0, 0, 0, 0, 1, 0, 0}, "Cold reservoir temperature", false},
            {"T_h", {0, 0, 0, 0, 1, 0, 0}, "Hot reservoir temperature", false}
        },
        "Thermodynamics",
        "Carnot Efficiency",
        "\\eta"
    });
    
    formulas.push_back({
        "Carnot Efficiency (solve for T_c)",
        "T_c = T_h(1 - \\eta)",
        {
            {"T_c", {0, 0, 0, 0, 1, 0, 0}, "Cold reservoir temperature", false},
            {"T_h", {0, 0, 0, 0, 1, 0, 0}, "Hot reservoir temperature", false},
            {"\\eta", {0, 0, 0, 0, 0, 0, 0}, "Efficiency", false}
        },
        "Thermodynamics",
        "Carnot Efficiency",
        "T_c"
    });
    
    formulas.push_back({
        "Carnot Efficiency (solve for T_h)",
        "T_h = \\frac{T_c}{1 - \\eta}",
        {
            {"T_h", {0, 0, 0, 0, 1, 0, 0}, "Hot reservoir temperature", false},
            {"T_c", {0, 0, 0, 0, 1, 0, 0}, "Cold reservoir temperature", false},
            {"\\eta", {0, 0, 0, 0, 0, 0, 0}, "Efficiency", false}
        },
        "Thermodynamics",
        "Carnot Efficiency",
        "T_h"
    });
}

} // namespace Physics
#include "physics_formulas.hpp"

namespace Physics {

void FormulaDatabase::initialize_waves() {
    
    // ========================================================================
    // WAVE VELOCITY: v = f * lambda
    // ========================================================================
    
    formulas.push_back({
        "Wave Velocity (solve for v)",
        "v = f\\lambda",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Wave velocity", false},
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"\\lambda", {1, 0, 0, 0, 0, 0, 0}, "Wavelength", false}
        },
        "Waves",
        "Wave Velocity",
        "v"
    });
    
    formulas.push_back({
        "Wave Velocity (solve for f)",
        "f = \\frac{v}{\\lambda}",
        {
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Wave velocity", false},
            {"\\lambda", {1, 0, 0, 0, 0, 0, 0}, "Wavelength", false}
        },
        "Waves",
        "Wave Velocity",
        "f"
    });
    
    formulas.push_back({
        "Wave Velocity (solve for lambda)",
        "\\lambda = \\frac{v}{f}",
        {
            {"\\lambda", {1, 0, 0, 0, 0, 0, 0}, "Wavelength", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Wave velocity", false},
            {"f", {0, -1, 0, 0, 0, 0, 0}, "Frequency", false}
        },
        "Waves",
        "Wave Velocity",
        "\\lambda"
    });
    
    // ========================================================================
    // WAVE SPEED ON STRING: v = sqrt(T/mu)
    // ========================================================================
    
    formulas.push_back({
        "Wave Speed on String (solve for v)",
        "v = \\sqrt{\\frac{T}{\\mu}}",
        {
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Wave velocity", false},
            {"T", {1, -2, 1, 0, 0, 0, 0}, "Tension", false},
            {"\\mu", {-1, 0, 1, 0, 0, 0, 0}, "Linear mass density", false}
        },
        "Waves",
        "Wave Speed on String",
        "v"
    });
    
    formulas.push_back({
        "Wave Speed on String (solve for T)",
        "T = \\mu v^2",
        {
            {"T", {1, -2, 1, 0, 0, 0, 0}, "Tension", false},
            {"\\mu", {-1, 0, 1, 0, 0, 0, 0}, "Linear mass density", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Wave velocity", false}
        },
        "Waves",
        "Wave Speed on String",
        "T"
    });
    
    formulas.push_back({
        "Wave Speed on String (solve for mu)",
        "\\mu = \\frac{T}{v^2}",
        {
            {"\\mu", {-1, 0, 1, 0, 0, 0, 0}, "Linear mass density", false},
            {"T", {1, -2, 1, 0, 0, 0, 0}, "Tension", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Wave velocity", false}
        },
        "Waves",
        "Wave Speed on String",
        "\\mu"
    });
    
    // ========================================================================
    // DOPPLER EFFECT (SOUND): f_obs = f_source * (v +/- v_obs) / (v -/+ v_source)
    // Simplified for stationary observer
    // ========================================================================
    
    formulas.push_back({
        "Doppler Effect Moving Source (solve for f_obs)",
        "f_{obs} = f_s \\frac{v}{v \\mp v_s}",
        {
            {"f_{obs}", {0, -1, 0, 0, 0, 0, 0}, "Observed frequency", false},
            {"f_s", {0, -1, 0, 0, 0, 0, 0}, "Source frequency", false},
            {"v", {1, -1, 0, 0, 0, 0, 0}, "Wave velocity", false},
            {"v_s", {1, -1, 0, 0, 0, 0, 0}, "Source velocity", false}
        },
        "Waves",
        "Doppler Effect Moving Source",
        "f_{obs}"
    });
}

} // namespace Physics
#ifndef PHYSICS_FORMULAS_HPP
#define PHYSICS_FORMULAS_HPP

#include <string>
#include <vector>
#include "../dimeval.hpp"

namespace Physics {

struct Variable {
    std::string name;                    // "F", "q_1", "r", etc.
    dv::UnitVector units;           // [m, s, kg, A, K, mol, cd]
    std::string description;             // "Force", "Charge 1", "Distance"
    bool is_constant;                    // true for k, G, epsilon_0, etc.
};

struct Formula {
    std::string name;                    // "Coulomb's Law (solve for F)"
    std::string latex;                   // "F = k \\frac{q_1 q_2}{r^2}"
    std::vector<Variable> variables;     // All variables in the equation
    std::string category;                // "Electrostatics", "Kinematics", etc.
    std::string base_formula;            // "Coulomb's Law" (same for all variants)
    std::string solve_for;               // "F" (which variable this solves for)
};

class FormulaDatabase {
public:
    FormulaDatabase();
    const std::vector<Formula>& get_formulas() const { return formulas; }
    
private:
    std::vector<Formula> formulas;
    
    // Each category has its own initialization function
    // Implemented in separate cpp files
    void initialize_electrostatics();
    void initialize_circuits();
    void initialize_magnetism();
    void initialize_induction();
    void initialize_electromagnetic_waves();
    void initialize_kinematics();
    void initialize_dynamics();
    void initialize_circular_motion();
    void initialize_gravity();
    void initialize_energy();
    void initialize_momentum();
    void initialize_rotational_mechanics();
    void initialize_oscillations();
    void initialize_waves();
    void initialize_fluids();
    void initialize_thermodynamics();
    void initialize_optics();
    void initialize_modern_physics();
    void initialize_chemistry_basic();
    void initialize_chemistry_solutions();
    void initialize_chemistry_kinetics();
    void initialize_chemistry_equilibrium();
    void initialize_chemistry_acids_bases();
    void initialize_chemistry_thermochemistry();
    void initialize_chemistry_electrochemistry();
};

} // namespace Physics

#endif // PHYSICS_FORMULAS_HPP
#include "physics_formulas.hpp"

namespace Physics {

FormulaDatabase::FormulaDatabase() {
    // Initialize all formula categories
    // Each function is implemented in its own cpp file
    initialize_electrostatics();
    initialize_circuits();
    initialize_magnetism();
    initialize_induction();
    initialize_electromagnetic_waves();
    initialize_kinematics();
    initialize_dynamics();
    initialize_circular_motion();
    initialize_gravity();
    initialize_energy();
    initialize_momentum();
    initialize_rotational_mechanics();
    initialize_oscillations();
    initialize_waves();
    initialize_fluids();
    initialize_thermodynamics();
    initialize_optics();
    initialize_modern_physics();
    initialize_chemistry_basic();
    initialize_chemistry_solutions();
    initialize_chemistry_kinetics();
    initialize_chemistry_equilibrium();
    initialize_chemistry_acids_bases();
    initialize_chemistry_thermochemistry();
    initialize_chemistry_electrochemistry();
}

} // namespace Physics
